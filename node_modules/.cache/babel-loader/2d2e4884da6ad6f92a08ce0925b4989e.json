{"ast":null,"code":"'use strict'; // rfc7231 6.1\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar statusCodeCacheableByDefault = [200, 203, 204, 206, 300, 301, 404, 405, 410, 414, 501]; // This implementation does not understand partial responses (206)\n\nvar understoodStatuses = [200, 203, 204, 300, 301, 302, 303, 307, 308, 404, 405, 410, 414, 501];\nvar hopByHopHeaders = {\n  'connection': true,\n  'keep-alive': true,\n  'proxy-authenticate': true,\n  'proxy-authorization': true,\n  'te': true,\n  'trailer': true,\n  'transfer-encoding': true,\n  'upgrade': true\n};\nvar excludedFromRevalidationUpdate = {\n  // Since the old body is reused, it doesn't make sense to change properties of the body\n  'content-length': true,\n  'content-encoding': true,\n  'transfer-encoding': true,\n  'content-range': true\n};\n\nfunction parseCacheControl(header) {\n  var cc = {};\n  if (!header) return cc; // TODO: When there is more than one value present for a given directive (e.g., two Expires header fields, multiple Cache-Control: max-age directives),\n  // the directive's value is considered invalid. Caches are encouraged to consider responses that have invalid freshness information to be stale\n\n  var parts = header.trim().split(/\\s*,\\s*/); // TODO: lame parsing\n\n  for (var _iterator = parts, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var part = _ref;\n\n    var _part$split = part.split(/\\s*=\\s*/, 2),\n        k = _part$split[0],\n        v = _part$split[1];\n\n    cc[k] = v === undefined ? true : v.replace(/^\"|\"$/g, ''); // TODO: lame unquoting\n  }\n\n  return cc;\n}\n\nfunction formatCacheControl(cc) {\n  var parts = [];\n\n  for (var k in cc) {\n    var v = cc[k];\n    parts.push(v === true ? k : k + '=' + v);\n  }\n\n  if (!parts.length) {\n    return undefined;\n  }\n\n  return parts.join(', ');\n}\n\nmodule.exports = function () {\n  function CachePolicy(req, res) {\n    var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        shared = _ref2.shared,\n        cacheHeuristic = _ref2.cacheHeuristic,\n        immutableMinTimeToLive = _ref2.immutableMinTimeToLive,\n        ignoreCargoCult = _ref2.ignoreCargoCult,\n        _fromObject = _ref2._fromObject;\n\n    _classCallCheck(this, CachePolicy);\n\n    if (_fromObject) {\n      this._fromObject(_fromObject);\n\n      return;\n    }\n\n    if (!res || !res.headers) {\n      throw Error(\"Response headers missing\");\n    }\n\n    this._assertRequestHasHeaders(req);\n\n    this._responseTime = this.now();\n    this._isShared = shared !== false;\n    this._cacheHeuristic = undefined !== cacheHeuristic ? cacheHeuristic : 0.1; // 10% matches IE\n\n    this._immutableMinTtl = undefined !== immutableMinTimeToLive ? immutableMinTimeToLive : 24 * 3600 * 1000;\n    this._status = 'status' in res ? res.status : 200;\n    this._resHeaders = res.headers;\n    this._rescc = parseCacheControl(res.headers['cache-control']);\n    this._method = 'method' in req ? req.method : 'GET';\n    this._url = req.url;\n    this._host = req.headers.host;\n    this._noAuthorization = !req.headers.authorization;\n    this._reqHeaders = res.headers.vary ? req.headers : null; // Don't keep all request headers if they won't be used\n\n    this._reqcc = parseCacheControl(req.headers['cache-control']); // Assume that if someone uses legacy, non-standard uncecessary options they don't understand caching,\n    // so there's no point stricly adhering to the blindly copy&pasted directives.\n\n    if (ignoreCargoCult && \"pre-check\" in this._rescc && \"post-check\" in this._rescc) {\n      delete this._rescc['pre-check'];\n      delete this._rescc['post-check'];\n      delete this._rescc['no-cache'];\n      delete this._rescc['no-store'];\n      delete this._rescc['must-revalidate'];\n      this._resHeaders = Object.assign({}, this._resHeaders, {\n        'cache-control': formatCacheControl(this._rescc)\n      });\n      delete this._resHeaders.expires;\n      delete this._resHeaders.pragma;\n    } // When the Cache-Control header field is not present in a request, caches MUST consider the no-cache request pragma-directive\n    // as having the same effect as if \"Cache-Control: no-cache\" were present (see Section 5.2.1).\n\n\n    if (!res.headers['cache-control'] && /no-cache/.test(res.headers.pragma)) {\n      this._rescc['no-cache'] = true;\n    }\n  }\n\n  CachePolicy.prototype.now = function now() {\n    return Date.now();\n  };\n\n  CachePolicy.prototype.storable = function storable() {\n    // The \"no-store\" request directive indicates that a cache MUST NOT store any part of either this request or any response to it.\n    return !!(!this._reqcc['no-store'] && ( // A cache MUST NOT store a response to any request, unless:\n    // The request method is understood by the cache and defined as being cacheable, and\n    'GET' === this._method || 'HEAD' === this._method || 'POST' === this._method && this._hasExplicitExpiration()) && // the response status code is understood by the cache, and\n    understoodStatuses.indexOf(this._status) !== -1 && // the \"no-store\" cache directive does not appear in request or response header fields, and\n    !this._rescc['no-store'] && ( // the \"private\" response directive does not appear in the response, if the cache is shared, and\n    !this._isShared || !this._rescc.private) && ( // the Authorization header field does not appear in the request, if the cache is shared,\n    !this._isShared || this._noAuthorization || this._allowsStoringAuthenticated()) && ( // the response either:\n    // contains an Expires header field, or\n    this._resHeaders.expires || // contains a max-age response directive, or\n    // contains a s-maxage response directive and the cache is shared, or\n    // contains a public response directive.\n    this._rescc.public || this._rescc['max-age'] || this._rescc['s-maxage'] || // has a status code that is defined as cacheable by default\n    statusCodeCacheableByDefault.indexOf(this._status) !== -1));\n  };\n\n  CachePolicy.prototype._hasExplicitExpiration = function _hasExplicitExpiration() {\n    // 4.2.1 Calculating Freshness Lifetime\n    return this._isShared && this._rescc['s-maxage'] || this._rescc['max-age'] || this._resHeaders.expires;\n  };\n\n  CachePolicy.prototype._assertRequestHasHeaders = function _assertRequestHasHeaders(req) {\n    if (!req || !req.headers) {\n      throw Error(\"Request headers missing\");\n    }\n  };\n\n  CachePolicy.prototype.satisfiesWithoutRevalidation = function satisfiesWithoutRevalidation(req) {\n    this._assertRequestHasHeaders(req); // When presented with a request, a cache MUST NOT reuse a stored response, unless:\n    // the presented request does not contain the no-cache pragma (Section 5.4), nor the no-cache cache directive,\n    // unless the stored response is successfully validated (Section 4.3), and\n\n\n    var requestCC = parseCacheControl(req.headers['cache-control']);\n\n    if (requestCC['no-cache'] || /no-cache/.test(req.headers.pragma)) {\n      return false;\n    }\n\n    if (requestCC['max-age'] && this.age() > requestCC['max-age']) {\n      return false;\n    }\n\n    if (requestCC['min-fresh'] && this.timeToLive() < 1000 * requestCC['min-fresh']) {\n      return false;\n    } // the stored response is either:\n    // fresh, or allowed to be served stale\n\n\n    if (this.stale()) {\n      var allowsStale = requestCC['max-stale'] && !this._rescc['must-revalidate'] && (true === requestCC['max-stale'] || requestCC['max-stale'] > this.age() - this.maxAge());\n\n      if (!allowsStale) {\n        return false;\n      }\n    }\n\n    return this._requestMatches(req, false);\n  };\n\n  CachePolicy.prototype._requestMatches = function _requestMatches(req, allowHeadMethod) {\n    // The presented effective request URI and that of the stored response match, and\n    return (!this._url || this._url === req.url) && this._host === req.headers.host && ( // the request method associated with the stored response allows it to be used for the presented request, and\n    !req.method || this._method === req.method || allowHeadMethod && 'HEAD' === req.method) && // selecting header fields nominated by the stored response (if any) match those presented, and\n    this._varyMatches(req);\n  };\n\n  CachePolicy.prototype._allowsStoringAuthenticated = function _allowsStoringAuthenticated() {\n    //  following Cache-Control response directives (Section 5.2.2) have such an effect: must-revalidate, public, and s-maxage.\n    return this._rescc['must-revalidate'] || this._rescc.public || this._rescc['s-maxage'];\n  };\n\n  CachePolicy.prototype._varyMatches = function _varyMatches(req) {\n    if (!this._resHeaders.vary) {\n      return true;\n    } // A Vary header field-value of \"*\" always fails to match\n\n\n    if (this._resHeaders.vary === '*') {\n      return false;\n    }\n\n    var fields = this._resHeaders.vary.trim().toLowerCase().split(/\\s*,\\s*/);\n\n    for (var _iterator2 = fields, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n      var _ref3;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref3 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref3 = _i2.value;\n      }\n\n      var name = _ref3;\n      if (req.headers[name] !== this._reqHeaders[name]) return false;\n    }\n\n    return true;\n  };\n\n  CachePolicy.prototype._copyWithoutHopByHopHeaders = function _copyWithoutHopByHopHeaders(inHeaders) {\n    var headers = {};\n\n    for (var name in inHeaders) {\n      if (hopByHopHeaders[name]) continue;\n      headers[name] = inHeaders[name];\n    } // 9.1.  Connection\n\n\n    if (inHeaders.connection) {\n      var tokens = inHeaders.connection.trim().split(/\\s*,\\s*/);\n\n      for (var _iterator3 = tokens, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n        var _ref4;\n\n        if (_isArray3) {\n          if (_i3 >= _iterator3.length) break;\n          _ref4 = _iterator3[_i3++];\n        } else {\n          _i3 = _iterator3.next();\n          if (_i3.done) break;\n          _ref4 = _i3.value;\n        }\n\n        var _name = _ref4;\n        delete headers[_name];\n      }\n    }\n\n    if (headers.warning) {\n      var warnings = headers.warning.split(/,/).filter(function (warning) {\n        return !/^\\s*1[0-9][0-9]/.test(warning);\n      });\n\n      if (!warnings.length) {\n        delete headers.warning;\n      } else {\n        headers.warning = warnings.join(',').trim();\n      }\n    }\n\n    return headers;\n  };\n\n  CachePolicy.prototype.responseHeaders = function responseHeaders() {\n    var headers = this._copyWithoutHopByHopHeaders(this._resHeaders);\n\n    var age = this.age(); // A cache SHOULD generate 113 warning if it heuristically chose a freshness\n    // lifetime greater than 24 hours and the response's age is greater than 24 hours.\n\n    if (age > 3600 * 24 && !this._hasExplicitExpiration() && this.maxAge() > 3600 * 24) {\n      headers.warning = (headers.warning ? \"\".concat(headers.warning, \", \") : '') + '113 - \"rfc7234 5.5.4\"';\n    }\n\n    headers.age = \"\".concat(Math.round(age));\n    return headers;\n  };\n  /**\n   * Value of the Date response header or current time if Date was demed invalid\n   * @return timestamp\n   */\n\n\n  CachePolicy.prototype.date = function date() {\n    var dateValue = Date.parse(this._resHeaders.date);\n    var maxClockDrift = 8 * 3600 * 1000;\n\n    if (Number.isNaN(dateValue) || dateValue < this._responseTime - maxClockDrift || dateValue > this._responseTime + maxClockDrift) {\n      return this._responseTime;\n    }\n\n    return dateValue;\n  };\n  /**\n   * Value of the Age header, in seconds, updated for the current time.\n   * May be fractional.\n   *\n   * @return Number\n   */\n\n\n  CachePolicy.prototype.age = function age() {\n    var age = Math.max(0, (this._responseTime - this.date()) / 1000);\n\n    if (this._resHeaders.age) {\n      var ageValue = this._ageValue();\n\n      if (ageValue > age) age = ageValue;\n    }\n\n    var residentTime = (this.now() - this._responseTime) / 1000;\n    return age + residentTime;\n  };\n\n  CachePolicy.prototype._ageValue = function _ageValue() {\n    var ageValue = parseInt(this._resHeaders.age);\n    return isFinite(ageValue) ? ageValue : 0;\n  };\n  /**\n   * Value of applicable max-age (or heuristic equivalent) in seconds. This counts since response's `Date`.\n   *\n   * For an up-to-date value, see `timeToLive()`.\n   *\n   * @return Number\n   */\n\n\n  CachePolicy.prototype.maxAge = function maxAge() {\n    if (!this.storable() || this._rescc['no-cache']) {\n      return 0;\n    } // Shared responses with cookies are cacheable according to the RFC, but IMHO it'd be unwise to do so by default\n    // so this implementation requires explicit opt-in via public header\n\n\n    if (this._isShared && this._resHeaders['set-cookie'] && !this._rescc.public && !this._rescc.immutable) {\n      return 0;\n    }\n\n    if (this._resHeaders.vary === '*') {\n      return 0;\n    }\n\n    if (this._isShared) {\n      if (this._rescc['proxy-revalidate']) {\n        return 0;\n      } // if a response includes the s-maxage directive, a shared cache recipient MUST ignore the Expires field.\n\n\n      if (this._rescc['s-maxage']) {\n        return parseInt(this._rescc['s-maxage'], 10);\n      }\n    } // If a response includes a Cache-Control field with the max-age directive, a recipient MUST ignore the Expires field.\n\n\n    if (this._rescc['max-age']) {\n      return parseInt(this._rescc['max-age'], 10);\n    }\n\n    var defaultMinTtl = this._rescc.immutable ? this._immutableMinTtl : 0;\n    var dateValue = this.date();\n\n    if (this._resHeaders.expires) {\n      var expires = Date.parse(this._resHeaders.expires); // A cache recipient MUST interpret invalid date formats, especially the value \"0\", as representing a time in the past (i.e., \"already expired\").\n\n      if (Number.isNaN(expires) || expires < dateValue) {\n        return 0;\n      }\n\n      return Math.max(defaultMinTtl, (expires - dateValue) / 1000);\n    }\n\n    if (this._resHeaders['last-modified']) {\n      var lastModified = Date.parse(this._resHeaders['last-modified']);\n\n      if (isFinite(lastModified) && dateValue > lastModified) {\n        return Math.max(defaultMinTtl, (dateValue - lastModified) / 1000 * this._cacheHeuristic);\n      }\n    }\n\n    return defaultMinTtl;\n  };\n\n  CachePolicy.prototype.timeToLive = function timeToLive() {\n    return Math.max(0, this.maxAge() - this.age()) * 1000;\n  };\n\n  CachePolicy.prototype.stale = function stale() {\n    return this.maxAge() <= this.age();\n  };\n\n  CachePolicy.fromObject = function fromObject(obj) {\n    return new this(undefined, undefined, {\n      _fromObject: obj\n    });\n  };\n\n  CachePolicy.prototype._fromObject = function _fromObject(obj) {\n    if (this._responseTime) throw Error(\"Reinitialized\");\n    if (!obj || obj.v !== 1) throw Error(\"Invalid serialization\");\n    this._responseTime = obj.t;\n    this._isShared = obj.sh;\n    this._cacheHeuristic = obj.ch;\n    this._immutableMinTtl = obj.imm !== undefined ? obj.imm : 24 * 3600 * 1000;\n    this._status = obj.st;\n    this._resHeaders = obj.resh;\n    this._rescc = obj.rescc;\n    this._method = obj.m;\n    this._url = obj.u;\n    this._host = obj.h;\n    this._noAuthorization = obj.a;\n    this._reqHeaders = obj.reqh;\n    this._reqcc = obj.reqcc;\n  };\n\n  CachePolicy.prototype.toObject = function toObject() {\n    return {\n      v: 1,\n      t: this._responseTime,\n      sh: this._isShared,\n      ch: this._cacheHeuristic,\n      imm: this._immutableMinTtl,\n      st: this._status,\n      resh: this._resHeaders,\n      rescc: this._rescc,\n      m: this._method,\n      u: this._url,\n      h: this._host,\n      a: this._noAuthorization,\n      reqh: this._reqHeaders,\n      reqcc: this._reqcc\n    };\n  };\n  /**\n   * Headers for sending to the origin server to revalidate stale response.\n   * Allows server to return 304 to allow reuse of the previous response.\n   *\n   * Hop by hop headers are always stripped.\n   * Revalidation headers may be added or removed, depending on request.\n   */\n\n\n  CachePolicy.prototype.revalidationHeaders = function revalidationHeaders(incomingReq) {\n    this._assertRequestHasHeaders(incomingReq);\n\n    var headers = this._copyWithoutHopByHopHeaders(incomingReq.headers); // This implementation does not understand range requests\n\n\n    delete headers['if-range'];\n\n    if (!this._requestMatches(incomingReq, true) || !this.storable()) {\n      // revalidation allowed via HEAD\n      // not for the same resource, or wasn't allowed to be cached anyway\n      delete headers['if-none-match'];\n      delete headers['if-modified-since'];\n      return headers;\n    }\n    /* MUST send that entity-tag in any cache validation request (using If-Match or If-None-Match) if an entity-tag has been provided by the origin server. */\n\n\n    if (this._resHeaders.etag) {\n      headers['if-none-match'] = headers['if-none-match'] ? \"\".concat(headers['if-none-match'], \", \").concat(this._resHeaders.etag) : this._resHeaders.etag;\n    } // Clients MAY issue simple (non-subrange) GET requests with either weak validators or strong validators. Clients MUST NOT use weak validators in other forms of request.\n\n\n    var forbidsWeakValidators = headers['accept-ranges'] || headers['if-match'] || headers['if-unmodified-since'] || this._method && this._method != 'GET';\n    /* SHOULD send the Last-Modified value in non-subrange cache validation requests (using If-Modified-Since) if only a Last-Modified value has been provided by the origin server.\n    Note: This implementation does not understand partial responses (206) */\n\n    if (forbidsWeakValidators) {\n      delete headers['if-modified-since'];\n\n      if (headers['if-none-match']) {\n        var etags = headers['if-none-match'].split(/,/).filter(function (etag) {\n          return !/^\\s*W\\//.test(etag);\n        });\n\n        if (!etags.length) {\n          delete headers['if-none-match'];\n        } else {\n          headers['if-none-match'] = etags.join(',').trim();\n        }\n      }\n    } else if (this._resHeaders['last-modified'] && !headers['if-modified-since']) {\n      headers['if-modified-since'] = this._resHeaders['last-modified'];\n    }\n\n    return headers;\n  };\n  /**\n   * Creates new CachePolicy with information combined from the previews response,\n   * and the new revalidation response.\n   *\n   * Returns {policy, modified} where modified is a boolean indicating\n   * whether the response body has been modified, and old cached body can't be used.\n   *\n   * @return {Object} {policy: CachePolicy, modified: Boolean}\n   */\n\n\n  CachePolicy.prototype.revalidatedPolicy = function revalidatedPolicy(request, response) {\n    this._assertRequestHasHeaders(request);\n\n    if (!response || !response.headers) {\n      throw Error(\"Response headers missing\");\n    } // These aren't going to be supported exactly, since one CachePolicy object\n    // doesn't know about all the other cached objects.\n\n\n    var matches = false;\n\n    if (response.status !== undefined && response.status != 304) {\n      matches = false;\n    } else if (response.headers.etag && !/^\\s*W\\//.test(response.headers.etag)) {\n      // \"All of the stored responses with the same strong validator are selected.\n      // If none of the stored responses contain the same strong validator,\n      // then the cache MUST NOT use the new response to update any stored responses.\"\n      matches = this._resHeaders.etag && this._resHeaders.etag.replace(/^\\s*W\\//, '') === response.headers.etag;\n    } else if (this._resHeaders.etag && response.headers.etag) {\n      // \"If the new response contains a weak validator and that validator corresponds\n      // to one of the cache's stored responses,\n      // then the most recent of those matching stored responses is selected for update.\"\n      matches = this._resHeaders.etag.replace(/^\\s*W\\//, '') === response.headers.etag.replace(/^\\s*W\\//, '');\n    } else if (this._resHeaders['last-modified']) {\n      matches = this._resHeaders['last-modified'] === response.headers['last-modified'];\n    } else {\n      // If the new response does not include any form of validator (such as in the case where\n      // a client generates an If-Modified-Since request from a source other than the Last-Modified\n      // response header field), and there is only one stored response, and that stored response also\n      // lacks a validator, then that stored response is selected for update.\n      if (!this._resHeaders.etag && !this._resHeaders['last-modified'] && !response.headers.etag && !response.headers['last-modified']) {\n        matches = true;\n      }\n    }\n\n    if (!matches) {\n      return {\n        policy: new this.constructor(request, response),\n        modified: true\n      };\n    } // use other header fields provided in the 304 (Not Modified) response to replace all instances\n    // of the corresponding header fields in the stored response.\n\n\n    var headers = {};\n\n    for (var k in this._resHeaders) {\n      headers[k] = k in response.headers && !excludedFromRevalidationUpdate[k] ? response.headers[k] : this._resHeaders[k];\n    }\n\n    var newResponse = Object.assign({}, response, {\n      status: this._status,\n      method: this._method,\n      headers: headers\n    });\n    return {\n      policy: new this.constructor(request, newResponse),\n      modified: false\n    };\n  };\n\n  return CachePolicy;\n}();","map":null,"metadata":{},"sourceType":"script"}