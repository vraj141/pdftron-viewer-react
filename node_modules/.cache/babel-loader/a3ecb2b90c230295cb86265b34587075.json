{"ast":null,"code":"'use strict';\n\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\vrajs\\\\Desktop\\\\firebase-file-upload-pdftron-reactjs\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\vrajs\\\\Desktop\\\\firebase-file-upload-pdftron-reactjs\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:\\\\Users\\\\vrajs\\\\Desktop\\\\firebase-file-upload-pdftron-reactjs\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"C:\\\\Users\\\\vrajs\\\\Desktop\\\\firebase-file-upload-pdftron-reactjs\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/assertThisInitialized\");\n\nvar _wrapNativeSuper = require(\"C:\\\\Users\\\\vrajs\\\\Desktop\\\\firebase-file-upload-pdftron-reactjs\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/wrapNativeSuper\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\vrajs\\\\Desktop\\\\firebase-file-upload-pdftron-reactjs\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\vrajs\\\\Desktop\\\\firebase-file-upload-pdftron-reactjs\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar EventEmitter = require('events');\n\nvar urlLib = require('url');\n\nvar normalizeUrl = require('normalize-url');\n\nvar getStream = require('get-stream');\n\nvar CachePolicy = require('http-cache-semantics');\n\nvar Response = require('responselike');\n\nvar lowercaseKeys = require('lowercase-keys');\n\nvar cloneResponse = require('clone-response');\n\nvar Keyv = require('keyv');\n\nvar CacheableRequest = /*#__PURE__*/function () {\n  function CacheableRequest(request, cacheAdapter) {\n    _classCallCheck(this, CacheableRequest);\n\n    if (typeof request !== 'function') {\n      throw new TypeError('Parameter `request` must be a function');\n    }\n\n    this.cache = new Keyv({\n      uri: typeof cacheAdapter === 'string' && cacheAdapter,\n      store: typeof cacheAdapter !== 'string' && cacheAdapter,\n      namespace: 'cacheable-request'\n    });\n    return this.createCacheableRequest(request);\n  }\n\n  _createClass(CacheableRequest, [{\n    key: \"createCacheableRequest\",\n    value: function createCacheableRequest(request) {\n      var _this = this;\n\n      return function (opts, cb) {\n        if (typeof opts === 'string') {\n          opts = urlLib.parse(opts);\n        }\n\n        opts = Object.assign({\n          headers: {},\n          method: 'GET',\n          cache: true,\n          strictTtl: false,\n          automaticFailover: false\n        }, opts);\n        opts.headers = lowercaseKeys(opts.headers);\n        var ee = new EventEmitter();\n        var url = normalizeUrl(urlLib.format(opts));\n        var key = \"\".concat(opts.method, \":\").concat(url);\n        var revalidate = false;\n        var madeRequest = false;\n\n        var makeRequest = function makeRequest(opts) {\n          madeRequest = true;\n\n          var handler = function handler(response) {\n            if (revalidate) {\n              var revalidatedPolicy = CachePolicy.fromObject(revalidate.cachePolicy).revalidatedPolicy(opts, response);\n\n              if (!revalidatedPolicy.modified) {\n                var headers = revalidatedPolicy.policy.responseHeaders();\n                response = new Response(response.statusCode, headers, revalidate.body, revalidate.url);\n                response.cachePolicy = revalidatedPolicy.policy;\n                response.fromCache = true;\n              }\n            }\n\n            if (!response.fromCache) {\n              response.cachePolicy = new CachePolicy(opts, response);\n              response.fromCache = false;\n            }\n\n            var clonedResponse;\n\n            if (opts.cache && response.cachePolicy.storable()) {\n              clonedResponse = cloneResponse(response);\n              getStream.buffer(response).then(function (body) {\n                var value = {\n                  cachePolicy: response.cachePolicy.toObject(),\n                  url: response.url,\n                  statusCode: response.fromCache ? revalidate.statusCode : response.statusCode,\n                  body: body\n                };\n                var ttl = opts.strictTtl ? response.cachePolicy.timeToLive() : undefined;\n                return _this.cache.set(key, value, ttl);\n              }).catch(function (err) {\n                return ee.emit('error', new CacheableRequest.CacheError(err));\n              });\n            } else if (opts.cache && revalidate) {\n              _this.cache.delete(key).catch(function (err) {\n                return ee.emit('error', new CacheableRequest.CacheError(err));\n              });\n            }\n\n            ee.emit('response', clonedResponse || response);\n\n            if (typeof cb === 'function') {\n              cb(clonedResponse || response);\n            }\n          };\n\n          try {\n            var req = request(opts, handler);\n            ee.emit('request', req);\n          } catch (err) {\n            ee.emit('error', new CacheableRequest.RequestError(err));\n          }\n        };\n\n        var get = function get(opts) {\n          return Promise.resolve().then(function () {\n            return opts.cache ? _this.cache.get(key) : undefined;\n          }).then(function (cacheEntry) {\n            if (typeof cacheEntry === 'undefined') {\n              return makeRequest(opts);\n            }\n\n            var policy = CachePolicy.fromObject(cacheEntry.cachePolicy);\n\n            if (policy.satisfiesWithoutRevalidation(opts)) {\n              var headers = policy.responseHeaders();\n              var response = new Response(cacheEntry.statusCode, headers, cacheEntry.body, cacheEntry.url);\n              response.cachePolicy = policy;\n              response.fromCache = true;\n              ee.emit('response', response);\n\n              if (typeof cb === 'function') {\n                cb(response);\n              }\n            } else {\n              revalidate = cacheEntry;\n              opts.headers = policy.revalidationHeaders(opts);\n              makeRequest(opts);\n            }\n          });\n        };\n\n        _this.cache.on('error', function (err) {\n          return ee.emit('error', new CacheableRequest.CacheError(err));\n        });\n\n        get(opts).catch(function (err) {\n          if (opts.automaticFailover && !madeRequest) {\n            makeRequest(opts);\n          }\n\n          ee.emit('error', new CacheableRequest.CacheError(err));\n        });\n        return ee;\n      };\n    }\n  }]);\n\n  return CacheableRequest;\n}();\n\nCacheableRequest.RequestError = /*#__PURE__*/function (_Error) {\n  _inherits(_class, _Error);\n\n  function _class(err) {\n    var _this2;\n\n    _classCallCheck(this, _class);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(_class).call(this, err.message));\n    _this2.name = 'RequestError';\n    Object.assign(_assertThisInitialized(_assertThisInitialized(_this2)), err);\n    return _this2;\n  }\n\n  return _class;\n}(_wrapNativeSuper(Error));\n\nCacheableRequest.CacheError = /*#__PURE__*/function (_Error2) {\n  _inherits(_class2, _Error2);\n\n  function _class2(err) {\n    var _this3;\n\n    _classCallCheck(this, _class2);\n\n    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(_class2).call(this, err.message));\n    _this3.name = 'CacheError';\n    Object.assign(_assertThisInitialized(_assertThisInitialized(_this3)), err);\n    return _this3;\n  }\n\n  return _class2;\n}(_wrapNativeSuper(Error));\n\nmodule.exports = CacheableRequest;","map":null,"metadata":{},"sourceType":"script"}