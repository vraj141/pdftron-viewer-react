{"ast":null,"code":"var through = require('through');\n\nvar bz2 = require('./lib/bzip2');\n\nvar bitIterator = require('./lib/bit_iterator');\n\nmodule.exports = unbzip2Stream;\n\nfunction unbzip2Stream() {\n  var bufferQueue = [];\n  var hasBytes = 0;\n  var blockSize = 0;\n  var broken = false;\n  var done = false;\n  var bitReader = null;\n  var streamCRC = null;\n\n  function decompressBlock(push) {\n    if (!blockSize) {\n      blockSize = bz2.header(bitReader); //console.error(\"got header of\", blockSize);\n\n      streamCRC = 0;\n      return true;\n    } else {\n      var bufsize = 100000 * blockSize;\n      var buf = new Int32Array(bufsize);\n      var chunk = [];\n\n      var f = function f(b) {\n        chunk.push(b);\n      };\n\n      streamCRC = bz2.decompress(bitReader, f, buf, bufsize, streamCRC);\n\n      if (streamCRC === null) {\n        // reset for next bzip2 header\n        blockSize = 0;\n        return false;\n      } else {\n        //console.error('decompressed', chunk.length,'bytes');\n        push(Buffer.from(chunk));\n        return true;\n      }\n    }\n  }\n\n  var outlength = 0;\n\n  function decompressAndQueue(stream) {\n    if (broken) return;\n\n    try {\n      return decompressBlock(function (d) {\n        stream.queue(d);\n\n        if (d !== null) {\n          //console.error('write at', outlength.toString(16));\n          outlength += d.length;\n        } else {//console.error('written EOS');\n        }\n      });\n    } catch (e) {\n      //console.error(e);\n      stream.emit('error', e);\n      broken = true;\n      return false;\n    }\n  }\n\n  return through(function write(data) {\n    //console.error('received', data.length,'bytes in', typeof data);\n    bufferQueue.push(data);\n    hasBytes += data.length;\n\n    if (bitReader === null) {\n      bitReader = bitIterator(function () {\n        return bufferQueue.shift();\n      });\n    }\n\n    while (!broken && hasBytes - bitReader.bytesRead + 1 >= (25000 + 100000 * blockSize || 4)) {\n      //console.error('decompressing with', hasBytes - bitReader.bytesRead + 1, 'bytes in buffer');\n      decompressAndQueue(this);\n    }\n  }, function end(x) {\n    //console.error(x,'last compressing with', hasBytes, 'bytes in buffer');\n    while (!broken && bitReader && hasBytes > bitReader.bytesRead) {\n      decompressAndQueue(this);\n    }\n\n    if (!broken) {\n      if (streamCRC !== null) this.emit('error', new Error(\"input stream ended prematurely\"));\n      this.queue(null);\n    }\n  });\n}","map":null,"metadata":{},"sourceType":"script"}