{"ast":null,"code":"/*\nseek-bzip - a pure-javascript module for seeking within bzip2 data\n\nCopyright (C) 2013 C. Scott Ananian\nCopyright (C) 2012 Eli Skeggs\nCopyright (C) 2011 Kevin Kwok\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nAdapted from node-bzip, copyright 2012 Eli Skeggs.\nAdapted from bzip2.js, copyright 2011 Kevin Kwok (antimatter15@gmail.com).\n\nBased on micro-bunzip by Rob Landley (rob@landley.net).\n\nBased on bzip2 decompression code by Julian R Seward (jseward@acm.org),\nwhich also acknowledges contributions by Mike Burrows, David Wheeler,\nPeter Fenwick, Alistair Moffat, Radford Neal, Ian H. Witten,\nRobert Sedgewick, and Jon L. Bentley.\n*/\nvar BitReader = require('./bitreader');\n\nvar Stream = require('./stream');\n\nvar CRC32 = require('./crc32');\n\nvar pjson = require('../package.json');\n\nvar MAX_HUFCODE_BITS = 20;\nvar MAX_SYMBOLS = 258;\nvar SYMBOL_RUNA = 0;\nvar SYMBOL_RUNB = 1;\nvar MIN_GROUPS = 2;\nvar MAX_GROUPS = 6;\nvar GROUP_SIZE = 50;\nvar WHOLEPI = \"314159265359\";\nvar SQRTPI = \"177245385090\";\n\nvar mtf = function mtf(array, index) {\n  var src = array[index],\n      i;\n\n  for (i = index; i > 0; i--) {\n    array[i] = array[i - 1];\n  }\n\n  array[0] = src;\n  return src;\n};\n\nvar Err = {\n  OK: 0,\n  LAST_BLOCK: -1,\n  NOT_BZIP_DATA: -2,\n  UNEXPECTED_INPUT_EOF: -3,\n  UNEXPECTED_OUTPUT_EOF: -4,\n  DATA_ERROR: -5,\n  OUT_OF_MEMORY: -6,\n  OBSOLETE_INPUT: -7,\n  END_OF_BLOCK: -8\n};\nvar ErrorMessages = {};\nErrorMessages[Err.LAST_BLOCK] = \"Bad file checksum\";\nErrorMessages[Err.NOT_BZIP_DATA] = \"Not bzip data\";\nErrorMessages[Err.UNEXPECTED_INPUT_EOF] = \"Unexpected input EOF\";\nErrorMessages[Err.UNEXPECTED_OUTPUT_EOF] = \"Unexpected output EOF\";\nErrorMessages[Err.DATA_ERROR] = \"Data error\";\nErrorMessages[Err.OUT_OF_MEMORY] = \"Out of memory\";\nErrorMessages[Err.OBSOLETE_INPUT] = \"Obsolete (pre 0.9.5) bzip format not supported.\";\n\nvar _throw = function _throw(status, optDetail) {\n  var msg = ErrorMessages[status] || 'unknown error';\n\n  if (optDetail) {\n    msg += ': ' + optDetail;\n  }\n\n  var e = new TypeError(msg);\n  e.errorCode = status;\n  throw e;\n};\n\nvar Bunzip = function Bunzip(inputStream, outputStream) {\n  this.writePos = this.writeCurrent = this.writeCount = 0;\n\n  this._start_bunzip(inputStream, outputStream);\n};\n\nBunzip.prototype._init_block = function () {\n  var moreBlocks = this._get_next_block();\n\n  if (!moreBlocks) {\n    this.writeCount = -1;\n    return false;\n    /* no more blocks */\n  }\n\n  this.blockCRC = new CRC32();\n  return true;\n};\n/* XXX micro-bunzip uses (inputStream, inputBuffer, len) as arguments */\n\n\nBunzip.prototype._start_bunzip = function (inputStream, outputStream) {\n  /* Ensure that file starts with \"BZh['1'-'9'].\" */\n  var buf = new Buffer(4);\n  if (inputStream.read(buf, 0, 4) !== 4 || String.fromCharCode(buf[0], buf[1], buf[2]) !== 'BZh') _throw(Err.NOT_BZIP_DATA, 'bad magic');\n  var level = buf[3] - 0x30;\n  if (level < 1 || level > 9) _throw(Err.NOT_BZIP_DATA, 'level out of range');\n  this.reader = new BitReader(inputStream);\n  /* Fourth byte (ascii '1'-'9'), indicates block size in units of 100k of\n     uncompressed data.  Allocate intermediate buffer for block. */\n\n  this.dbufSize = 100000 * level;\n  this.nextoutput = 0;\n  this.outputStream = outputStream;\n  this.streamCRC = 0;\n};\n\nBunzip.prototype._get_next_block = function () {\n  var i, j, k;\n  var reader = this.reader; // this is get_next_block() function from micro-bunzip:\n\n  /* Read in header signature and CRC, then validate signature.\n     (last block signature means CRC is for whole file, return now) */\n\n  var h = reader.pi();\n\n  if (h === SQRTPI) {\n    // last block\n    return false;\n    /* no more blocks */\n  }\n\n  if (h !== WHOLEPI) _throw(Err.NOT_BZIP_DATA);\n  this.targetBlockCRC = reader.read(32) >>> 0; // (convert to unsigned)\n\n  this.streamCRC = (this.targetBlockCRC ^ (this.streamCRC << 1 | this.streamCRC >>> 31)) >>> 0;\n  /* We can add support for blockRandomised if anybody complains.  There was\n     some code for this in busybox 1.0.0-pre3, but nobody ever noticed that\n     it didn't actually work. */\n\n  if (reader.read(1)) _throw(Err.OBSOLETE_INPUT);\n  var origPointer = reader.read(24);\n  if (origPointer > this.dbufSize) _throw(Err.DATA_ERROR, 'initial position out of bounds');\n  /* mapping table: if some byte values are never used (encoding things\n     like ascii text), the compression code removes the gaps to have fewer\n     symbols to deal with, and writes a sparse bitfield indicating which\n     values were present.  We make a translation table to convert the symbols\n     back to the corresponding bytes. */\n\n  var t = reader.read(16);\n  var symToByte = new Buffer(256),\n      symTotal = 0;\n\n  for (i = 0; i < 16; i++) {\n    if (t & 1 << 0xF - i) {\n      var o = i * 16;\n      k = reader.read(16);\n\n      for (j = 0; j < 16; j++) {\n        if (k & 1 << 0xF - j) symToByte[symTotal++] = o + j;\n      }\n    }\n  }\n  /* How many different huffman coding groups does this block use? */\n\n\n  var groupCount = reader.read(3);\n  if (groupCount < MIN_GROUPS || groupCount > MAX_GROUPS) _throw(Err.DATA_ERROR);\n  /* nSelectors: Every GROUP_SIZE many symbols we select a new huffman coding\n     group.  Read in the group selector list, which is stored as MTF encoded\n     bit runs.  (MTF=Move To Front, as each value is used it's moved to the\n     start of the list.) */\n\n  var nSelectors = reader.read(15);\n  if (nSelectors === 0) _throw(Err.DATA_ERROR);\n  var mtfSymbol = new Buffer(256);\n\n  for (i = 0; i < groupCount; i++) {\n    mtfSymbol[i] = i;\n  }\n\n  var selectors = new Buffer(nSelectors); // was 32768...\n\n  for (i = 0; i < nSelectors; i++) {\n    /* Get next value */\n    for (j = 0; reader.read(1); j++) {\n      if (j >= groupCount) _throw(Err.DATA_ERROR);\n    }\n    /* Decode MTF to get the next selector */\n\n\n    selectors[i] = mtf(mtfSymbol, j);\n  }\n  /* Read the huffman coding tables for each group, which code for symTotal\n     literal symbols, plus two run symbols (RUNA, RUNB) */\n\n\n  var symCount = symTotal + 2;\n  var groups = [],\n      hufGroup;\n\n  for (j = 0; j < groupCount; j++) {\n    var length = new Buffer(symCount),\n        temp = new Uint16Array(MAX_HUFCODE_BITS + 1);\n    /* Read huffman code lengths for each symbol.  They're stored in\n       a way similar to mtf; record a starting value for the first symbol,\n       and an offset from the previous value for everys symbol after that. */\n\n    t = reader.read(5); // lengths\n\n    for (i = 0; i < symCount; i++) {\n      for (;;) {\n        if (t < 1 || t > MAX_HUFCODE_BITS) _throw(Err.DATA_ERROR);\n        /* If first bit is 0, stop.  Else second bit indicates whether\n           to increment or decrement the value. */\n\n        if (!reader.read(1)) break;\n        if (!reader.read(1)) t++;else t--;\n      }\n\n      length[i] = t;\n    }\n    /* Find largest and smallest lengths in this group */\n\n\n    var minLen, maxLen;\n    minLen = maxLen = length[0];\n\n    for (i = 1; i < symCount; i++) {\n      if (length[i] > maxLen) maxLen = length[i];else if (length[i] < minLen) minLen = length[i];\n    }\n    /* Calculate permute[], base[], and limit[] tables from length[].\n     *\n     * permute[] is the lookup table for converting huffman coded symbols\n     * into decoded symbols.  base[] is the amount to subtract from the\n     * value of a huffman symbol of a given length when using permute[].\n     *\n     * limit[] indicates the largest numerical value a symbol with a given\n     * number of bits can have.  This is how the huffman codes can vary in\n     * length: each code with a value>limit[length] needs another bit.\n     */\n\n\n    hufGroup = {};\n    groups.push(hufGroup);\n    hufGroup.permute = new Uint16Array(MAX_SYMBOLS);\n    hufGroup.limit = new Uint32Array(MAX_HUFCODE_BITS + 2);\n    hufGroup.base = new Uint32Array(MAX_HUFCODE_BITS + 1);\n    hufGroup.minLen = minLen;\n    hufGroup.maxLen = maxLen;\n    /* Calculate permute[].  Concurently, initialize temp[] and limit[]. */\n\n    var pp = 0;\n\n    for (i = minLen; i <= maxLen; i++) {\n      temp[i] = hufGroup.limit[i] = 0;\n\n      for (t = 0; t < symCount; t++) {\n        if (length[t] === i) hufGroup.permute[pp++] = t;\n      }\n    }\n    /* Count symbols coded for at each bit length */\n\n\n    for (i = 0; i < symCount; i++) {\n      temp[length[i]]++;\n    }\n    /* Calculate limit[] (the largest symbol-coding value at each bit\n     * length, which is (previous limit<<1)+symbols at this level), and\n     * base[] (number of symbols to ignore at each bit length, which is\n     * limit minus the cumulative count of symbols coded for already). */\n\n\n    pp = t = 0;\n\n    for (i = minLen; i < maxLen; i++) {\n      pp += temp[i];\n      /* We read the largest possible symbol size and then unget bits\n         after determining how many we need, and those extra bits could\n         be set to anything.  (They're noise from future symbols.)  At\n         each level we're really only interested in the first few bits,\n         so here we set all the trailing to-be-ignored bits to 1 so they\n         don't affect the value>limit[length] comparison. */\n\n      hufGroup.limit[i] = pp - 1;\n      pp <<= 1;\n      t += temp[i];\n      hufGroup.base[i + 1] = pp - t;\n    }\n\n    hufGroup.limit[maxLen + 1] = Number.MAX_VALUE;\n    /* Sentinal value for reading next sym. */\n\n    hufGroup.limit[maxLen] = pp + temp[maxLen] - 1;\n    hufGroup.base[minLen] = 0;\n  }\n  /* We've finished reading and digesting the block header.  Now read this\n     block's huffman coded symbols from the file and undo the huffman coding\n     and run length encoding, saving the result into dbuf[dbufCount++]=uc */\n\n  /* Initialize symbol occurrence counters and symbol Move To Front table */\n\n\n  var byteCount = new Uint32Array(256);\n\n  for (i = 0; i < 256; i++) {\n    mtfSymbol[i] = i;\n  }\n  /* Loop through compressed symbols. */\n\n\n  var runPos = 0,\n      dbufCount = 0,\n      selector = 0,\n      uc;\n  var dbuf = this.dbuf = new Uint32Array(this.dbufSize);\n  symCount = 0;\n\n  for (;;) {\n    /* Determine which huffman coding group to use. */\n    if (!symCount--) {\n      symCount = GROUP_SIZE - 1;\n\n      if (selector >= nSelectors) {\n        _throw(Err.DATA_ERROR);\n      }\n\n      hufGroup = groups[selectors[selector++]];\n    }\n    /* Read next huffman-coded symbol. */\n\n\n    i = hufGroup.minLen;\n    j = reader.read(i);\n\n    for (;; i++) {\n      if (i > hufGroup.maxLen) {\n        _throw(Err.DATA_ERROR);\n      }\n\n      if (j <= hufGroup.limit[i]) break;\n      j = j << 1 | reader.read(1);\n    }\n    /* Huffman decode value to get nextSym (with bounds checking) */\n\n\n    j -= hufGroup.base[i];\n\n    if (j < 0 || j >= MAX_SYMBOLS) {\n      _throw(Err.DATA_ERROR);\n    }\n\n    var nextSym = hufGroup.permute[j];\n    /* We have now decoded the symbol, which indicates either a new literal\n       byte, or a repeated run of the most recent literal byte.  First,\n       check if nextSym indicates a repeated run, and if so loop collecting\n       how many times to repeat the last literal. */\n\n    if (nextSym === SYMBOL_RUNA || nextSym === SYMBOL_RUNB) {\n      /* If this is the start of a new run, zero out counter */\n      if (!runPos) {\n        runPos = 1;\n        t = 0;\n      }\n      /* Neat trick that saves 1 symbol: instead of or-ing 0 or 1 at\n         each bit position, add 1 or 2 instead.  For example,\n         1011 is 1<<0 + 1<<1 + 2<<2.  1010 is 2<<0 + 2<<1 + 1<<2.\n         You can make any bit pattern that way using 1 less symbol than\n         the basic or 0/1 method (except all bits 0, which would use no\n         symbols, but a run of length 0 doesn't mean anything in this\n         context).  Thus space is saved. */\n\n\n      if (nextSym === SYMBOL_RUNA) t += runPos;else t += 2 * runPos;\n      runPos <<= 1;\n      continue;\n    }\n    /* When we hit the first non-run symbol after a run, we now know\n       how many times to repeat the last literal, so append that many\n       copies to our buffer of decoded symbols (dbuf) now.  (The last\n       literal used is the one at the head of the mtfSymbol array.) */\n\n\n    if (runPos) {\n      runPos = 0;\n\n      if (dbufCount + t > this.dbufSize) {\n        _throw(Err.DATA_ERROR);\n      }\n\n      uc = symToByte[mtfSymbol[0]];\n      byteCount[uc] += t;\n\n      while (t--) {\n        dbuf[dbufCount++] = uc;\n      }\n    }\n    /* Is this the terminating symbol? */\n\n\n    if (nextSym > symTotal) break;\n    /* At this point, nextSym indicates a new literal character.  Subtract\n       one to get the position in the MTF array at which this literal is\n       currently to be found.  (Note that the result can't be -1 or 0,\n       because 0 and 1 are RUNA and RUNB.  But another instance of the\n       first symbol in the mtf array, position 0, would have been handled\n       as part of a run above.  Therefore 1 unused mtf position minus\n       2 non-literal nextSym values equals -1.) */\n\n    if (dbufCount >= this.dbufSize) {\n      _throw(Err.DATA_ERROR);\n    }\n\n    i = nextSym - 1;\n    uc = mtf(mtfSymbol, i);\n    uc = symToByte[uc];\n    /* We have our literal byte.  Save it into dbuf. */\n\n    byteCount[uc]++;\n    dbuf[dbufCount++] = uc;\n  }\n  /* At this point, we've read all the huffman-coded symbols (and repeated\n     runs) for this block from the input stream, and decoded them into the\n     intermediate buffer.  There are dbufCount many decoded bytes in dbuf[].\n     Now undo the Burrows-Wheeler transform on dbuf.\n     See http://dogma.net/markn/articles/bwt/bwt.htm\n  */\n\n\n  if (origPointer < 0 || origPointer >= dbufCount) {\n    _throw(Err.DATA_ERROR);\n  }\n  /* Turn byteCount into cumulative occurrence counts of 0 to n-1. */\n\n\n  j = 0;\n\n  for (i = 0; i < 256; i++) {\n    k = j + byteCount[i];\n    byteCount[i] = j;\n    j = k;\n  }\n  /* Figure out what order dbuf would be in if we sorted it. */\n\n\n  for (i = 0; i < dbufCount; i++) {\n    uc = dbuf[i] & 0xff;\n    dbuf[byteCount[uc]] |= i << 8;\n    byteCount[uc]++;\n  }\n  /* Decode first byte by hand to initialize \"previous\" byte.  Note that it\n     doesn't get output, and if the first three characters are identical\n     it doesn't qualify as a run (hence writeRunCountdown=5). */\n\n\n  var pos = 0,\n      current = 0,\n      run = 0;\n\n  if (dbufCount) {\n    pos = dbuf[origPointer];\n    current = pos & 0xff;\n    pos >>= 8;\n    run = -1;\n  }\n\n  this.writePos = pos;\n  this.writeCurrent = current;\n  this.writeCount = dbufCount;\n  this.writeRun = run;\n  return true;\n  /* more blocks to come */\n};\n/* Undo burrows-wheeler transform on intermediate buffer to produce output.\n   If start_bunzip was initialized with out_fd=-1, then up to len bytes of\n   data are written to outbuf.  Return value is number of bytes written or\n   error (all errors are negative numbers).  If out_fd!=-1, outbuf and len\n   are ignored, data is written to out_fd and return is RETVAL_OK or error.\n*/\n\n\nBunzip.prototype._read_bunzip = function (outputBuffer, len) {\n  var copies, previous, outbyte;\n  /* james@jamestaylor.org: writeCount goes to -1 when the buffer is fully\n     decoded, which results in this returning RETVAL_LAST_BLOCK, also\n     equal to -1... Confusing, I'm returning 0 here to indicate no\n     bytes written into the buffer */\n\n  if (this.writeCount < 0) {\n    return 0;\n  }\n\n  var gotcount = 0;\n  var dbuf = this.dbuf,\n      pos = this.writePos,\n      current = this.writeCurrent;\n  var dbufCount = this.writeCount,\n      outputsize = this.outputsize;\n  var run = this.writeRun;\n\n  while (dbufCount) {\n    dbufCount--;\n    previous = current;\n    pos = dbuf[pos];\n    current = pos & 0xff;\n    pos >>= 8;\n\n    if (run++ === 3) {\n      copies = current;\n      outbyte = previous;\n      current = -1;\n    } else {\n      copies = 1;\n      outbyte = current;\n    }\n\n    this.blockCRC.updateCRCRun(outbyte, copies);\n\n    while (copies--) {\n      this.outputStream.writeByte(outbyte);\n      this.nextoutput++;\n    }\n\n    if (current != previous) run = 0;\n  }\n\n  this.writeCount = dbufCount; // check CRC\n\n  if (this.blockCRC.getCRC() !== this.targetBlockCRC) {\n    _throw(Err.DATA_ERROR, \"Bad block CRC \" + \"(got \" + this.blockCRC.getCRC().toString(16) + \" expected \" + this.targetBlockCRC.toString(16) + \")\");\n  }\n\n  return this.nextoutput;\n};\n\nvar coerceInputStream = function coerceInputStream(input) {\n  if ('readByte' in input) {\n    return input;\n  }\n\n  var inputStream = new Stream();\n  inputStream.pos = 0;\n\n  inputStream.readByte = function () {\n    return input[this.pos++];\n  };\n\n  inputStream.seek = function (pos) {\n    this.pos = pos;\n  };\n\n  inputStream.eof = function () {\n    return this.pos >= input.length;\n  };\n\n  return inputStream;\n};\n\nvar coerceOutputStream = function coerceOutputStream(output) {\n  var outputStream = new Stream();\n  var resizeOk = true;\n\n  if (output) {\n    if (typeof output === 'number') {\n      outputStream.buffer = new Buffer(output);\n      resizeOk = false;\n    } else if ('writeByte' in output) {\n      return output;\n    } else {\n      outputStream.buffer = output;\n      resizeOk = false;\n    }\n  } else {\n    outputStream.buffer = new Buffer(16384);\n  }\n\n  outputStream.pos = 0;\n\n  outputStream.writeByte = function (_byte) {\n    if (resizeOk && this.pos >= this.buffer.length) {\n      var newBuffer = new Buffer(this.buffer.length * 2);\n      this.buffer.copy(newBuffer);\n      this.buffer = newBuffer;\n    }\n\n    this.buffer[this.pos++] = _byte;\n  };\n\n  outputStream.getBuffer = function () {\n    // trim buffer\n    if (this.pos !== this.buffer.length) {\n      if (!resizeOk) throw new TypeError('outputsize does not match decoded input');\n      var newBuffer = new Buffer(this.pos);\n      this.buffer.copy(newBuffer, 0, 0, this.pos);\n      this.buffer = newBuffer;\n    }\n\n    return this.buffer;\n  };\n\n  outputStream._coerced = true;\n  return outputStream;\n};\n/* Static helper functions */\n\n\nBunzip.Err = Err; // 'input' can be a stream or a buffer\n// 'output' can be a stream or a buffer or a number (buffer size)\n\nBunzip.decode = function (input, output, multistream) {\n  // make a stream from a buffer, if necessary\n  var inputStream = coerceInputStream(input);\n  var outputStream = coerceOutputStream(output);\n  var bz = new Bunzip(inputStream, outputStream);\n\n  while (true) {\n    if ('eof' in inputStream && inputStream.eof()) break;\n\n    if (bz._init_block()) {\n      bz._read_bunzip();\n    } else {\n      var targetStreamCRC = bz.reader.read(32) >>> 0; // (convert to unsigned)\n\n      if (targetStreamCRC !== bz.streamCRC) {\n        _throw(Err.DATA_ERROR, \"Bad stream CRC \" + \"(got \" + bz.streamCRC.toString(16) + \" expected \" + targetStreamCRC.toString(16) + \")\");\n      }\n\n      if (multistream && 'eof' in inputStream && !inputStream.eof()) {\n        // note that start_bunzip will also resync the bit reader to next byte\n        bz._start_bunzip(inputStream, outputStream);\n      } else break;\n    }\n  }\n\n  if ('getBuffer' in outputStream) return outputStream.getBuffer();\n};\n\nBunzip.decodeBlock = function (input, pos, output) {\n  // make a stream from a buffer, if necessary\n  var inputStream = coerceInputStream(input);\n  var outputStream = coerceOutputStream(output);\n  var bz = new Bunzip(inputStream, outputStream);\n  bz.reader.seek(pos);\n  /* Fill the decode buffer for the block */\n\n  var moreBlocks = bz._get_next_block();\n\n  if (moreBlocks) {\n    /* Init the CRC for writing */\n    bz.blockCRC = new CRC32();\n    /* Zero this so the current byte from before the seek is not written */\n\n    bz.writeCopies = 0;\n    /* Decompress the block and write to stdout */\n\n    bz._read_bunzip(); // XXX keep writing?\n\n  }\n\n  if ('getBuffer' in outputStream) return outputStream.getBuffer();\n};\n/* Reads bzip2 file from stream or buffer `input`, and invoke\n * `callback(position, size)` once for each bzip2 block,\n * where position gives the starting position (in *bits*)\n * and size gives uncompressed size of the block (in *bytes*). */\n\n\nBunzip.table = function (input, callback, multistream) {\n  // make a stream from a buffer, if necessary\n  var inputStream = new Stream();\n  inputStream.delegate = coerceInputStream(input);\n  inputStream.pos = 0;\n\n  inputStream.readByte = function () {\n    this.pos++;\n    return this.delegate.readByte();\n  };\n\n  if (inputStream.delegate.eof) {\n    inputStream.eof = inputStream.delegate.eof.bind(inputStream.delegate);\n  }\n\n  var outputStream = new Stream();\n  outputStream.pos = 0;\n\n  outputStream.writeByte = function () {\n    this.pos++;\n  };\n\n  var bz = new Bunzip(inputStream, outputStream);\n  var blockSize = bz.dbufSize;\n\n  while (true) {\n    if ('eof' in inputStream && inputStream.eof()) break;\n    var position = inputStream.pos * 8 + bz.reader.bitOffset;\n\n    if (bz.reader.hasByte) {\n      position -= 8;\n    }\n\n    if (bz._init_block()) {\n      var start = outputStream.pos;\n\n      bz._read_bunzip();\n\n      callback(position, outputStream.pos - start);\n    } else {\n      var crc = bz.reader.read(32); // (but we ignore the crc)\n\n      if (multistream && 'eof' in inputStream && !inputStream.eof()) {\n        // note that start_bunzip will also resync the bit reader to next byte\n        bz._start_bunzip(inputStream, outputStream);\n\n        console.assert(bz.dbufSize === blockSize, \"shouldn't change block size within multistream file\");\n      } else break;\n    }\n  }\n};\n\nBunzip.Stream = Stream;\nBunzip.version = pjson.version;\nBunzip.license = pjson.license;\nmodule.exports = Bunzip;","map":null,"metadata":{},"sourceType":"script"}