{"ast":null,"code":"'use strict';\n\nvar url = require('url');\n\nvar punycode = require('punycode');\n\nvar queryString = require('query-string');\n\nvar prependHttp = require('prepend-http');\n\nvar sortKeys = require('sort-keys');\n\nvar DEFAULT_PORTS = {\n  'http:': 80,\n  'https:': 443,\n  'ftp:': 21\n}; // Protocols that always contain a `//`` bit\n\nvar slashedProtocol = {\n  http: true,\n  https: true,\n  ftp: true,\n  gopher: true,\n  file: true,\n  'http:': true,\n  'https:': true,\n  'ftp:': true,\n  'gopher:': true,\n  'file:': true\n};\n\nfunction testParameter(name, filters) {\n  return filters.some(function (filter) {\n    return filter instanceof RegExp ? filter.test(name) : filter === name;\n  });\n}\n\nmodule.exports = function (str, opts) {\n  opts = Object.assign({\n    normalizeProtocol: true,\n    normalizeHttps: false,\n    stripFragment: true,\n    stripWWW: true,\n    removeQueryParameters: [/^utm_\\w+/i],\n    removeTrailingSlash: true,\n    removeDirectoryIndex: false,\n    sortQueryParameters: true\n  }, opts);\n\n  if (typeof str !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  var hasRelativeProtocol = str.startsWith('//'); // Prepend protocol\n\n  str = prependHttp(str.trim()).replace(/^\\/\\//, 'http://');\n  var urlObj = url.parse(str);\n\n  if (opts.normalizeHttps && urlObj.protocol === 'https:') {\n    urlObj.protocol = 'http:';\n  }\n\n  if (!urlObj.hostname && !urlObj.pathname) {\n    throw new Error('Invalid URL');\n  } // Prevent these from being used by `url.format`\n\n\n  delete urlObj.host;\n  delete urlObj.query; // Remove fragment\n\n  if (opts.stripFragment) {\n    delete urlObj.hash;\n  } // Remove default port\n\n\n  var port = DEFAULT_PORTS[urlObj.protocol];\n\n  if (Number(urlObj.port) === port) {\n    delete urlObj.port;\n  } // Remove duplicate slashes\n\n\n  if (urlObj.pathname) {\n    urlObj.pathname = urlObj.pathname.replace(/\\/{2,}/g, '/');\n  } // Decode URI octets\n\n\n  if (urlObj.pathname) {\n    urlObj.pathname = decodeURI(urlObj.pathname);\n  } // Remove directory index\n\n\n  if (opts.removeDirectoryIndex === true) {\n    opts.removeDirectoryIndex = [/^index\\.[a-z]+$/];\n  }\n\n  if (Array.isArray(opts.removeDirectoryIndex) && opts.removeDirectoryIndex.length > 0) {\n    var pathComponents = urlObj.pathname.split('/');\n    var lastComponent = pathComponents[pathComponents.length - 1];\n\n    if (testParameter(lastComponent, opts.removeDirectoryIndex)) {\n      pathComponents = pathComponents.slice(0, pathComponents.length - 1);\n      urlObj.pathname = pathComponents.slice(1).join('/') + '/';\n    }\n  } // Resolve relative paths, but only for slashed protocols\n\n\n  if (slashedProtocol[urlObj.protocol]) {\n    var domain = urlObj.protocol + '//' + urlObj.hostname;\n    var relative = url.resolve(domain, urlObj.pathname);\n    urlObj.pathname = relative.replace(domain, '');\n  }\n\n  if (urlObj.hostname) {\n    // IDN to Unicode\n    urlObj.hostname = punycode.toUnicode(urlObj.hostname).toLowerCase(); // Remove trailing dot\n\n    urlObj.hostname = urlObj.hostname.replace(/\\.$/, ''); // Remove `www.`\n\n    if (opts.stripWWW) {\n      urlObj.hostname = urlObj.hostname.replace(/^www\\./, '');\n    }\n  } // Remove URL with empty query string\n\n\n  if (urlObj.search === '?') {\n    delete urlObj.search;\n  }\n\n  var queryParameters = queryString.parse(urlObj.search); // Remove query unwanted parameters\n\n  if (Array.isArray(opts.removeQueryParameters)) {\n    for (var key in queryParameters) {\n      if (testParameter(key, opts.removeQueryParameters)) {\n        delete queryParameters[key];\n      }\n    }\n  } // Sort query parameters\n\n\n  if (opts.sortQueryParameters) {\n    urlObj.search = queryString.stringify(sortKeys(queryParameters));\n  } // Decode query parameters\n\n\n  if (urlObj.search !== null) {\n    urlObj.search = decodeURIComponent(urlObj.search);\n  } // Take advantage of many of the Node `url` normalizations\n\n\n  str = url.format(urlObj); // Remove ending `/`\n\n  if (opts.removeTrailingSlash || urlObj.pathname === '/') {\n    str = str.replace(/\\/$/, '');\n  } // Restore relative protocol, if applicable\n\n\n  if (hasRelativeProtocol && !opts.normalizeProtocol) {\n    str = str.replace(/^http:\\/\\//, '//');\n  }\n\n  return str;\n};","map":null,"metadata":{},"sourceType":"script"}