{"ast":null,"code":"exports.parse = exports.decode = decode;\nexports.stringify = exports.encode = encode;\nexports.safe = safe;\nexports.unsafe = unsafe;\nvar eol = typeof process !== 'undefined' && process.platform === 'win32' ? '\\r\\n' : '\\n';\n\nfunction encode(obj, opt) {\n  var children = [];\n  var out = '';\n\n  if (typeof opt === 'string') {\n    opt = {\n      section: opt,\n      whitespace: false\n    };\n  } else {\n    opt = opt || {};\n    opt.whitespace = opt.whitespace === true;\n  }\n\n  var separator = opt.whitespace ? ' = ' : '=';\n  Object.keys(obj).forEach(function (k, _, __) {\n    var val = obj[k];\n\n    if (val && Array.isArray(val)) {\n      val.forEach(function (item) {\n        out += safe(k + '[]') + separator + safe(item) + '\\n';\n      });\n    } else if (val && typeof val === 'object') children.push(k);else out += safe(k) + separator + safe(val) + eol;\n  });\n  if (opt.section && out.length) out = '[' + safe(opt.section) + ']' + eol + out;\n  children.forEach(function (k, _, __) {\n    var nk = dotSplit(k).join('\\\\.');\n    var section = (opt.section ? opt.section + '.' : '') + nk;\n    var child = encode(obj[k], {\n      section: section,\n      whitespace: opt.whitespace\n    });\n    if (out.length && child.length) out += eol;\n    out += child;\n  });\n  return out;\n}\n\nfunction dotSplit(str) {\n  return str.replace(/\\1/g, \"\\x02LITERAL\\\\1LITERAL\\x02\").replace(/\\\\\\./g, \"\\x01\").split(/\\./).map(function (part) {\n    return part.replace(/\\1/g, '\\\\.').replace(/\\2LITERAL\\\\1LITERAL\\2/g, \"\\x01\");\n  });\n}\n\nfunction decode(str) {\n  var out = {};\n  var p = out;\n  var section = null; //          section     |key      = value\n\n  var re = /^\\[([^\\]]*)\\]$|^([^=]+)(=(.*))?$/i;\n  var lines = str.split(/[\\r\\n]+/g);\n  lines.forEach(function (line, _, __) {\n    if (!line || line.match(/^\\s*[;#]/)) return;\n    var match = line.match(re);\n    if (!match) return;\n\n    if (match[1] !== undefined) {\n      section = unsafe(match[1]);\n\n      if (section === '__proto__') {\n        // not allowed\n        // keep parsing the section, but don't attach it.\n        p = {};\n        return;\n      }\n\n      p = out[section] = out[section] || {};\n      return;\n    }\n\n    var key = unsafe(match[2]);\n    if (key === '__proto__') return;\n    var value = match[3] ? unsafe(match[4]) : true;\n\n    switch (value) {\n      case 'true':\n      case 'false':\n      case 'null':\n        value = JSON.parse(value);\n    } // Convert keys with '[]' suffix to an array\n\n\n    if (key.length > 2 && key.slice(-2) === '[]') {\n      key = key.substring(0, key.length - 2);\n      if (key === '__proto__') return;\n      if (!p[key]) p[key] = [];else if (!Array.isArray(p[key])) p[key] = [p[key]];\n    } // safeguard against resetting a previously defined\n    // array by accidentally forgetting the brackets\n\n\n    if (Array.isArray(p[key])) p[key].push(value);else p[key] = value;\n  }); // {a:{y:1},\"a.b\":{x:2}} --> {a:{y:1,b:{x:2}}}\n  // use a filter to return the keys that have to be deleted.\n\n  Object.keys(out).filter(function (k, _, __) {\n    if (!out[k] || typeof out[k] !== 'object' || Array.isArray(out[k])) return false; // see if the parent section is also an object.\n    // if so, add it to that, and mark this one for deletion\n\n    var parts = dotSplit(k);\n    var p = out;\n    var l = parts.pop();\n    var nl = l.replace(/\\\\\\./g, '.');\n    parts.forEach(function (part, _, __) {\n      if (part === '__proto__') return;\n      if (!p[part] || typeof p[part] !== 'object') p[part] = {};\n      p = p[part];\n    });\n    if (p === out && nl === l) return false;\n    p[nl] = out[k];\n    return true;\n  }).forEach(function (del, _, __) {\n    delete out[del];\n  });\n  return out;\n}\n\nfunction isQuoted(val) {\n  return val.charAt(0) === '\"' && val.slice(-1) === '\"' || val.charAt(0) === \"'\" && val.slice(-1) === \"'\";\n}\n\nfunction safe(val) {\n  return typeof val !== 'string' || val.match(/[=\\r\\n]/) || val.match(/^\\[/) || val.length > 1 && isQuoted(val) || val !== val.trim() ? JSON.stringify(val) : val.replace(/;/g, '\\\\;').replace(/#/g, '\\\\#');\n}\n\nfunction unsafe(val, doUnesc) {\n  val = (val || '').trim();\n\n  if (isQuoted(val)) {\n    // remove the single quotes before calling JSON.parse\n    if (val.charAt(0) === \"'\") val = val.substr(1, val.length - 2);\n\n    try {\n      val = JSON.parse(val);\n    } catch (_) {}\n  } else {\n    // walk the val to find the first not-escaped ; character\n    var esc = false;\n    var unesc = '';\n\n    for (var i = 0, l = val.length; i < l; i++) {\n      var c = val.charAt(i);\n\n      if (esc) {\n        if ('\\\\;#'.indexOf(c) !== -1) unesc += c;else unesc += '\\\\' + c;\n        esc = false;\n      } else if (';#'.indexOf(c) !== -1) break;else if (c === '\\\\') esc = true;else unesc += c;\n    }\n\n    if (esc) unesc += '\\\\';\n    return unesc.trim();\n  }\n\n  return val;\n}","map":null,"metadata":{},"sourceType":"script"}