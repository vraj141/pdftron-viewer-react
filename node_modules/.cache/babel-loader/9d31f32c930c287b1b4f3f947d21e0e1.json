{"ast":null,"code":"'use strict';\n\nvar EventEmitter = require('events');\n\nvar http = require('http');\n\nvar https = require('https');\n\nvar PassThrough = require('stream').PassThrough;\n\nvar Transform = require('stream').Transform;\n\nvar urlLib = require('url');\n\nvar fs = require('fs');\n\nvar querystring = require('querystring');\n\nvar CacheableRequest = require('cacheable-request');\n\nvar duplexer3 = require('duplexer3');\n\nvar intoStream = require('into-stream');\n\nvar is = require('@sindresorhus/is');\n\nvar getStream = require('get-stream');\n\nvar timedOut = require('timed-out');\n\nvar urlParseLax = require('url-parse-lax');\n\nvar urlToOptions = require('url-to-options');\n\nvar lowercaseKeys = require('lowercase-keys');\n\nvar decompressResponse = require('decompress-response');\n\nvar mimicResponse = require('mimic-response');\n\nvar isRetryAllowed = require('is-retry-allowed');\n\nvar isURL = require('isurl');\n\nvar PCancelable = require('p-cancelable');\n\nvar pTimeout = require('p-timeout');\n\nvar pify = require('pify');\n\nvar Buffer = require('safe-buffer').Buffer;\n\nvar pkg = require('./package.json');\n\nvar errors = require('./errors');\n\nvar getMethodRedirectCodes = new Set([300, 301, 302, 303, 304, 305, 307, 308]);\nvar allMethodRedirectCodes = new Set([300, 303, 307, 308]);\n\nvar isFormData = function isFormData(body) {\n  return is.nodeStream(body) && is.function(body.getBoundary);\n};\n\nvar getBodySize = function getBodySize(opts) {\n  var body = opts.body;\n\n  if (opts.headers['content-length']) {\n    return Number(opts.headers['content-length']);\n  }\n\n  if (!body && !opts.stream) {\n    return 0;\n  }\n\n  if (is.string(body)) {\n    return Buffer.byteLength(body);\n  }\n\n  if (isFormData(body)) {\n    return pify(body.getLength.bind(body))();\n  }\n\n  if (body instanceof fs.ReadStream) {\n    return pify(fs.stat)(body.path).then(function (stat) {\n      return stat.size;\n    });\n  }\n\n  if (is.nodeStream(body) && is.buffer(body._buffer)) {\n    return body._buffer.length;\n  }\n\n  return null;\n};\n\nfunction requestAsEventEmitter(opts) {\n  opts = opts || {};\n  var ee = new EventEmitter();\n  var requestUrl = opts.href || urlLib.resolve(urlLib.format(opts), opts.path);\n  var redirects = [];\n  var agents = is.object(opts.agent) ? opts.agent : null;\n  var retryCount = 0;\n  var redirectUrl;\n  var uploadBodySize;\n  var uploaded = 0;\n\n  var get = function get(opts) {\n    if (opts.protocol !== 'http:' && opts.protocol !== 'https:') {\n      ee.emit('error', new got.UnsupportedProtocolError(opts));\n      return;\n    }\n\n    var fn = opts.protocol === 'https:' ? https : http;\n\n    if (agents) {\n      var protocolName = opts.protocol === 'https:' ? 'https' : 'http';\n      opts.agent = agents[protocolName] || opts.agent;\n    }\n\n    if (opts.useElectronNet && process.versions.electron) {\n      var electron = require('electron');\n\n      fn = electron.net || electron.remote.net;\n    }\n\n    var progressInterval;\n    var cacheableRequest = new CacheableRequest(fn.request, opts.cache);\n    var cacheReq = cacheableRequest(opts, function (res) {\n      clearInterval(progressInterval);\n      ee.emit('uploadProgress', {\n        percent: 1,\n        transferred: uploaded,\n        total: uploadBodySize\n      });\n      var statusCode = res.statusCode;\n      res.url = redirectUrl || requestUrl;\n      res.requestUrl = requestUrl;\n      var followRedirect = opts.followRedirect && 'location' in res.headers;\n      var redirectGet = followRedirect && getMethodRedirectCodes.has(statusCode);\n      var redirectAll = followRedirect && allMethodRedirectCodes.has(statusCode);\n\n      if (redirectAll || redirectGet && (opts.method === 'GET' || opts.method === 'HEAD')) {\n        res.resume();\n\n        if (statusCode === 303) {\n          // Server responded with \"see other\", indicating that the resource exists at another location,\n          // and the client should request it from that location via GET or HEAD.\n          opts.method = 'GET';\n        }\n\n        if (redirects.length >= 10) {\n          ee.emit('error', new got.MaxRedirectsError(statusCode, redirects, opts), null, res);\n          return;\n        }\n\n        var bufferString = Buffer.from(res.headers.location, 'binary').toString();\n        redirectUrl = urlLib.resolve(urlLib.format(opts), bufferString);\n        redirects.push(redirectUrl);\n        var redirectOpts = Object.assign({}, opts, urlLib.parse(redirectUrl));\n        ee.emit('redirect', res, redirectOpts);\n        get(redirectOpts);\n        return;\n      }\n\n      setImmediate(function () {\n        try {\n          getResponse(res, opts, ee, redirects);\n        } catch (e) {\n          ee.emit('error', e);\n        }\n      });\n    });\n    cacheReq.on('error', function (err) {\n      if (err instanceof CacheableRequest.RequestError) {\n        ee.emit('error', new got.RequestError(err, opts));\n      } else {\n        ee.emit('error', new got.CacheError(err, opts));\n      }\n    });\n    cacheReq.once('request', function (req) {\n      var aborted = false;\n      req.once('abort', function (_) {\n        aborted = true;\n      });\n      req.once('error', function (err) {\n        clearInterval(progressInterval);\n\n        if (aborted) {\n          return;\n        }\n\n        var backoff = opts.retries(++retryCount, err);\n\n        if (backoff) {\n          setTimeout(get, backoff, opts);\n          return;\n        }\n\n        ee.emit('error', new got.RequestError(err, opts));\n      });\n      ee.once('request', function (req) {\n        ee.emit('uploadProgress', {\n          percent: 0,\n          transferred: 0,\n          total: uploadBodySize\n        });\n        var socket = req.connection;\n\n        if (socket) {\n          // `._connecting` was the old property which was made public in node v6.1.0\n          var isConnecting = socket.connecting === undefined ? socket._connecting : socket.connecting;\n\n          var onSocketConnect = function onSocketConnect() {\n            var uploadEventFrequency = 150;\n            progressInterval = setInterval(function () {\n              if (socket.destroyed) {\n                clearInterval(progressInterval);\n                return;\n              }\n\n              var lastUploaded = uploaded;\n              var headersSize = req._header ? Buffer.byteLength(req._header) : 0;\n              uploaded = socket.bytesWritten - headersSize; // Prevent the known issue of `bytesWritten` being larger than body size\n\n              if (uploadBodySize && uploaded > uploadBodySize) {\n                uploaded = uploadBodySize;\n              } // Don't emit events with unchanged progress and\n              // prevent last event from being emitted, because\n              // it's emitted when `response` is emitted\n\n\n              if (uploaded === lastUploaded || uploaded === uploadBodySize) {\n                return;\n              }\n\n              ee.emit('uploadProgress', {\n                percent: uploadBodySize ? uploaded / uploadBodySize : 0,\n                transferred: uploaded,\n                total: uploadBodySize\n              });\n            }, uploadEventFrequency);\n          }; // Only subscribe to 'connect' event if we're actually connecting a new\n          // socket, otherwise if we're already connected (because this is a\n          // keep-alive connection) do not bother. This is important since we won't\n          // get a 'connect' event for an already connected socket.\n\n\n          if (isConnecting) {\n            socket.once('connect', onSocketConnect);\n          } else {\n            onSocketConnect();\n          }\n        }\n      });\n\n      if (opts.gotTimeout) {\n        clearInterval(progressInterval);\n        timedOut(req, opts.gotTimeout);\n      }\n\n      setImmediate(function () {\n        ee.emit('request', req);\n      });\n    });\n  };\n\n  setImmediate(function () {\n    Promise.resolve(getBodySize(opts)).then(function (size) {\n      uploadBodySize = size;\n\n      if (is.undefined(opts.headers['content-length']) && is.undefined(opts.headers['transfer-encoding']) && isFormData(opts.body)) {\n        opts.headers['content-length'] = size;\n      }\n\n      get(opts);\n    }).catch(function (err) {\n      ee.emit('error', err);\n    });\n  });\n  return ee;\n}\n\nfunction getResponse(res, opts, ee, redirects) {\n  var downloadBodySize = Number(res.headers['content-length']) || null;\n  var downloaded = 0;\n  var progressStream = new Transform({\n    transform: function transform(chunk, encoding, callback) {\n      downloaded += chunk.length;\n      var percent = downloadBodySize ? downloaded / downloadBodySize : 0; // Let flush() be responsible for emitting the last event\n\n      if (percent < 1) {\n        ee.emit('downloadProgress', {\n          percent: percent,\n          transferred: downloaded,\n          total: downloadBodySize\n        });\n      }\n\n      callback(null, chunk);\n    },\n    flush: function flush(callback) {\n      ee.emit('downloadProgress', {\n        percent: 1,\n        transferred: downloaded,\n        total: downloadBodySize\n      });\n      callback();\n    }\n  });\n  mimicResponse(res, progressStream);\n  progressStream.redirectUrls = redirects;\n  var response = opts.decompress === true && is.function(decompressResponse) && opts.method !== 'HEAD' ? decompressResponse(progressStream) : progressStream;\n\n  if (!opts.decompress && ['gzip', 'deflate'].indexOf(res.headers['content-encoding']) !== -1) {\n    opts.encoding = null;\n  }\n\n  ee.emit('response', response);\n  ee.emit('downloadProgress', {\n    percent: 0,\n    transferred: 0,\n    total: downloadBodySize\n  });\n  res.pipe(progressStream);\n}\n\nfunction asPromise(opts) {\n  var timeoutFn = function timeoutFn(requestPromise) {\n    return opts.gotTimeout && opts.gotTimeout.request ? pTimeout(requestPromise, opts.gotTimeout.request, new got.RequestError({\n      message: 'Request timed out',\n      code: 'ETIMEDOUT'\n    }, opts)) : requestPromise;\n  };\n\n  var proxy = new EventEmitter();\n  var cancelable = new PCancelable(function (resolve, reject, onCancel) {\n    var ee = requestAsEventEmitter(opts);\n    var cancelOnRequest = false;\n    onCancel(function () {\n      cancelOnRequest = true;\n    });\n    ee.on('request', function (req) {\n      if (cancelOnRequest) {\n        req.abort();\n      }\n\n      onCancel(function () {\n        req.abort();\n      });\n\n      if (is.nodeStream(opts.body)) {\n        opts.body.pipe(req);\n        opts.body = undefined;\n        return;\n      }\n\n      req.end(opts.body);\n    });\n    ee.on('response', function (res) {\n      var stream = is.null(opts.encoding) ? getStream.buffer(res) : getStream(res, opts);\n      stream.catch(function (err) {\n        return reject(new got.ReadError(err, opts));\n      }).then(function (data) {\n        var statusCode = res.statusCode;\n        var limitStatusCode = opts.followRedirect ? 299 : 399;\n        res.body = data;\n\n        if (opts.json && res.body) {\n          try {\n            res.body = JSON.parse(res.body);\n          } catch (err) {\n            if (statusCode >= 200 && statusCode < 300) {\n              throw new got.ParseError(err, statusCode, opts, data);\n            }\n          }\n        }\n\n        if (opts.throwHttpErrors && statusCode !== 304 && (statusCode < 200 || statusCode > limitStatusCode)) {\n          throw new got.HTTPError(statusCode, res.statusMessage, res.headers, opts);\n        }\n\n        resolve(res);\n      }).catch(function (err) {\n        Object.defineProperty(err, 'response', {\n          value: res\n        });\n        reject(err);\n      });\n    });\n    ee.once('error', reject);\n    ee.on('redirect', proxy.emit.bind(proxy, 'redirect'));\n    ee.on('uploadProgress', proxy.emit.bind(proxy, 'uploadProgress'));\n    ee.on('downloadProgress', proxy.emit.bind(proxy, 'downloadProgress'));\n  }); // Preserve backwards-compatibility\n  // TODO: Remove this in the next major version\n\n  Object.defineProperty(cancelable, 'canceled', {\n    get: function get() {\n      return cancelable.isCanceled;\n    }\n  });\n  var promise = timeoutFn(cancelable);\n  promise.cancel = cancelable.cancel.bind(cancelable);\n\n  promise.on = function (name, fn) {\n    proxy.on(name, fn);\n    return promise;\n  };\n\n  return promise;\n}\n\nfunction asStream(opts) {\n  opts.stream = true;\n  var input = new PassThrough();\n  var output = new PassThrough();\n  var proxy = duplexer3(input, output);\n  var timeout;\n\n  if (opts.gotTimeout && opts.gotTimeout.request) {\n    timeout = setTimeout(function () {\n      proxy.emit('error', new got.RequestError({\n        message: 'Request timed out',\n        code: 'ETIMEDOUT'\n      }, opts));\n    }, opts.gotTimeout.request);\n  }\n\n  if (opts.json) {\n    throw new Error('Got can not be used as a stream when the `json` option is used');\n  }\n\n  if (opts.body) {\n    proxy.write = function () {\n      throw new Error('Got\\'s stream is not writable when the `body` option is used');\n    };\n  }\n\n  var ee = requestAsEventEmitter(opts);\n  ee.on('request', function (req) {\n    proxy.emit('request', req);\n\n    if (is.nodeStream(opts.body)) {\n      opts.body.pipe(req);\n      return;\n    }\n\n    if (opts.body) {\n      req.end(opts.body);\n      return;\n    }\n\n    if (opts.method === 'POST' || opts.method === 'PUT' || opts.method === 'PATCH') {\n      input.pipe(req);\n      return;\n    }\n\n    req.end();\n  });\n  ee.on('response', function (res) {\n    clearTimeout(timeout);\n    var statusCode = res.statusCode;\n    res.on('error', function (err) {\n      proxy.emit('error', new got.ReadError(err, opts));\n    });\n    res.pipe(output);\n\n    if (opts.throwHttpErrors && statusCode !== 304 && (statusCode < 200 || statusCode > 299)) {\n      proxy.emit('error', new got.HTTPError(statusCode, res.statusMessage, res.headers, opts), null, res);\n      return;\n    }\n\n    proxy.emit('response', res);\n  });\n  ee.on('error', proxy.emit.bind(proxy, 'error'));\n  ee.on('redirect', proxy.emit.bind(proxy, 'redirect'));\n  ee.on('uploadProgress', proxy.emit.bind(proxy, 'uploadProgress'));\n  ee.on('downloadProgress', proxy.emit.bind(proxy, 'downloadProgress'));\n  return proxy;\n}\n\nfunction normalizeArguments(url, opts) {\n  if (!is.string(url) && !is.object(url)) {\n    throw new TypeError(\"Parameter `url` must be a string or object, not \".concat(is(url)));\n  } else if (is.string(url)) {\n    url = url.replace(/^unix:/, 'http://$&');\n\n    try {\n      decodeURI(url);\n    } catch (err) {\n      throw new Error('Parameter `url` must contain valid UTF-8 character sequences');\n    }\n\n    url = urlParseLax(url);\n\n    if (url.auth) {\n      throw new Error('Basic authentication must be done with the `auth` option');\n    }\n  } else if (isURL.lenient(url)) {\n    url = urlToOptions(url);\n  }\n\n  opts = Object.assign({\n    path: '',\n    retries: 2,\n    cache: false,\n    decompress: true,\n    useElectronNet: false,\n    throwHttpErrors: true\n  }, url, {\n    protocol: url.protocol || 'http:' // Override both null/undefined with default protocol\n\n  }, opts);\n  var headers = lowercaseKeys(opts.headers);\n\n  for (var _i = 0, _Object$keys = Object.keys(headers); _i < _Object$keys.length; _i++) {\n    var key = _Object$keys[_i];\n\n    if (is.nullOrUndefined(headers[key])) {\n      delete headers[key];\n    }\n  }\n\n  opts.headers = Object.assign({\n    'user-agent': \"\".concat(pkg.name, \"/\").concat(pkg.version, \" (https://github.com/sindresorhus/got)\")\n  }, headers);\n\n  if (opts.decompress && is.undefined(opts.headers['accept-encoding'])) {\n    opts.headers['accept-encoding'] = 'gzip, deflate';\n  }\n\n  var query = opts.query;\n\n  if (query) {\n    if (!is.string(query)) {\n      opts.query = querystring.stringify(query);\n    }\n\n    opts.path = \"\".concat(opts.path.split('?')[0], \"?\").concat(opts.query);\n    delete opts.query;\n  }\n\n  if (opts.json && is.undefined(opts.headers.accept)) {\n    opts.headers.accept = 'application/json';\n  }\n\n  var body = opts.body;\n\n  if (is.nullOrUndefined(body)) {\n    opts.method = (opts.method || 'GET').toUpperCase();\n  } else {\n    var _headers = opts.headers;\n\n    if (!is.nodeStream(body) && !is.string(body) && !is.buffer(body) && !(opts.form || opts.json)) {\n      throw new TypeError('The `body` option must be a stream.Readable, string, Buffer or plain Object');\n    }\n\n    var canBodyBeStringified = is.plainObject(body) || is.array(body);\n\n    if ((opts.form || opts.json) && !canBodyBeStringified) {\n      throw new TypeError('The `body` option must be a plain Object or Array when the `form` or `json` option is used');\n    }\n\n    if (isFormData(body)) {\n      // Special case for https://github.com/form-data/form-data\n      _headers['content-type'] = _headers['content-type'] || \"multipart/form-data; boundary=\".concat(body.getBoundary());\n    } else if (opts.form && canBodyBeStringified) {\n      _headers['content-type'] = _headers['content-type'] || 'application/x-www-form-urlencoded';\n      opts.body = querystring.stringify(body);\n    } else if (opts.json && canBodyBeStringified) {\n      _headers['content-type'] = _headers['content-type'] || 'application/json';\n      opts.body = JSON.stringify(body);\n    }\n\n    if (is.undefined(_headers['content-length']) && is.undefined(_headers['transfer-encoding']) && !is.nodeStream(body)) {\n      var length = is.string(opts.body) ? Buffer.byteLength(opts.body) : opts.body.length;\n      _headers['content-length'] = length;\n    } // Convert buffer to stream to receive upload progress events\n    // see https://github.com/sindresorhus/got/pull/322\n\n\n    if (is.buffer(body)) {\n      opts.body = intoStream(body);\n      opts.body._buffer = body;\n    }\n\n    opts.method = (opts.method || 'POST').toUpperCase();\n  }\n\n  if (opts.hostname === 'unix') {\n    var matches = /(.+?):(.+)/.exec(opts.path);\n\n    if (matches) {\n      opts.socketPath = matches[1];\n      opts.path = matches[2];\n      opts.host = null;\n    }\n  }\n\n  if (!is.function(opts.retries)) {\n    var retries = opts.retries;\n\n    opts.retries = function (iter, err) {\n      if (iter > retries || !isRetryAllowed(err)) {\n        return 0;\n      }\n\n      var noise = Math.random() * 100;\n      return (1 << iter) * 1000 + noise;\n    };\n  }\n\n  if (is.undefined(opts.followRedirect)) {\n    opts.followRedirect = true;\n  }\n\n  if (opts.timeout) {\n    if (is.number(opts.timeout)) {\n      opts.gotTimeout = {\n        request: opts.timeout\n      };\n    } else {\n      opts.gotTimeout = opts.timeout;\n    }\n\n    delete opts.timeout;\n  }\n\n  return opts;\n}\n\nfunction got(url, opts) {\n  try {\n    var normalizedArgs = normalizeArguments(url, opts);\n\n    if (normalizedArgs.stream) {\n      return asStream(normalizedArgs);\n    }\n\n    return asPromise(normalizedArgs);\n  } catch (err) {\n    return Promise.reject(err);\n  }\n}\n\ngot.stream = function (url, opts) {\n  return asStream(normalizeArguments(url, opts));\n};\n\nvar methods = ['get', 'post', 'put', 'patch', 'head', 'delete'];\n\nvar _loop = function _loop() {\n  var method = _methods[_i2];\n\n  got[method] = function (url, opts) {\n    return got(url, Object.assign({}, opts, {\n      method: method\n    }));\n  };\n\n  got.stream[method] = function (url, opts) {\n    return got.stream(url, Object.assign({}, opts, {\n      method: method\n    }));\n  };\n};\n\nfor (var _i2 = 0, _methods = methods; _i2 < _methods.length; _i2++) {\n  _loop();\n}\n\nObject.assign(got, errors);\nmodule.exports = got;","map":null,"metadata":{},"sourceType":"script"}