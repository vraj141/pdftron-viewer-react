export declare module collab-server
{
	import ConnectedUserMap from './util/ConnectedUserMap';
	import { UserResolvers } from './resolvers';
	import { CorsOptions, PubSub } from 'apollo-server';
	import type winston from 'winston';
	import { Logging } from '../../../shared/log/logger';
	import { PermissionSetting, UserPermissionSetting } from './util/permission';
	import { InvitedUserInput } from '../../../types/resolvers-types';
	import { Response } from 'express';
	import { EmailManager } from './email/EmailManager';
	import ContextCache from './cache/ContextCache';
	import RequestStats from './util/RequestStats';
	import { RequestedFields } from './util/getRequestedFields';
	export type UserAuth = {
	    id: string;
	    userName?: string;
	};
	/**
	 * @ignore
	 */
	export type Context = {
	    res: Response;
	    user: UserAuth;
	    permissionSetting: PermissionSetting;
	    verifyPassword: VerifyPassword;
	    getUserFromToken: GetUserFromToken;
	    jwtCookieName: string;
	    cache: ContextCache;
	    resolvers: UserResolvers;
	    stats: RequestStats;
	    token?: string;
	    connectedUsers: ConnectedUserMap;
	    pubsub: PubSub;
	    emailOptions: CollabServerEmailOptions;
	    emailManager: EmailManager;
	    requestedFields: RequestedFields;
	    subscriptionFields: Record<string, RequestedFields>;
	};
	export type VerifyPassword = (email: string, password: string) => Promise<boolean> | boolean;
	export type GetUserFromToken = (token: string) => Promise<UserAuth> | UserAuth;
	/**
	 * @ignore
	 */
	export enum Email {
	    Message = "message",
	    Invite = "invite"
	}
	export type InviteEmailData = {
	    documentName: string;
	    documentId: string;
	    usersInvited: InvitedUserInput[];
	    sentBy: string;
	    sendTo: string[];
	};
	export type MessageData = {
	    annotationId: string;
	    messageText: string;
	    documentName: string;
	    documentId: string;
	    sentBy: string;
	    sendTo: string[];
	};
	export type MessageEmailData = {
	    messages: Omit<MessageData, 'sendTo'>[];
	    sendTo: string;
	};
	export type EmailFunction = (type: Email, data: InviteEmailData | MessageEmailData) => Promise<void>;
	export type CollabServerEmailOptions = {
	    emailHandler?: EmailFunction;
	    emailQueueTimer?: number;
	    emailOnAnnotationCreated?: boolean;
	};
	export interface ResolverObj {
	    [key: string]: {
	        [key: string]: (parent: any, args: any, context: any, info: any) => Promise<any>;
	    };
	}
	export type CollabServerCustomQueriesOptions = {
	    additionalTypeDefs: string;
	    additionalResolvers: ResolverObj;
	};
	export type CollabServerOptions = {
	    resolvers: UserResolvers;
	    corsOption?: CorsOptions;
	    idGenerator?: () => string | Promise<string>;
	    logLevel?: Logging;
	    logTransports?: Array<winston.transport>;
	    customQueries?: CollabServerCustomQueriesOptions;
	    emailOptions?: CollabServerEmailOptions;
	    verifyPassword?: VerifyPassword;
	    getUserFromToken?: GetUserFromToken;
	    jwtCookieName?: string;
	    permissions?: UserPermissionSetting;
	};
	class CollabServer {
	    private server;
	    generateId: () => Promise<string>;
	    constructor(options: CollabServerOptions);
	    static LogLevels: {
	        readonly ERROR: "error";
	        readonly WARN: "warn";
	        readonly INFO: "info";
	        readonly HTTP: "http";
	        readonly VERBOSE: "verbose";
	        readonly DEBUG: "debug";
	        readonly SILLY: "silly";
	        readonly NONE: "none";
	    };
	    static sendGridEmailHandler: (emailServiceOptions: import("./email/sendGridEmailHandler").EmailServiceOptions) => EmailFunction;
	    static Permissions: {
	        Roles: {
	            readonly DOCUMENT_AUTHOR: "document_author";
	            readonly DOCUMENT_MEMBER: "document_member";
	            readonly ANNOTATION_AUTHOR: "annotation_author";
	            readonly ANY: "any";
	        };
	        Actions: {
	            readonly READ: "read";
	            readonly ADD: "add";
	            readonly EDIT: "edit";
	            readonly DELETE: "delete";
	            readonly INVITE: "invite";
	        };
	        Entities: {
	            readonly DOCUMENT: "document";
	            readonly ANNOTATION: "annotation";
	        };
	    };
	    start(port?: number): Promise<void>;
	    stop(): Promise<void>;
	}
	export default CollabServer;
	/**
	 * @ignore
	 * Applies a layer of formatting in front of all user resolvers
	 * Right now just changes all timestamps
	 */
	export const applyFormattersToResolvers: (resolvers: UserResolvers) => UserResolvers;
	export * from './resolvers';
	export { default as Permissions, PermissionSetting, UserPermissionSetting, setPermissions, Roles, Actions, EntityPermissions, AuthMethod, AuthorizeFunction } from './util/permission';
	export { default as sendGridEmailHandler, EmailServiceOptions } from './email/sendGridEmailHandler';

	type ScrollPosition = {
	    scrollTop: number;
	    scrollHeight: number;
	};
	type ScrollSyncValue = {
	    userId: string;
	    position: ScrollPosition;
	};
	class UserConnection {
	    userId: any;
	    timeConnected: number;
	    currentDocuments: DocumentConnection[];
	    currentPageMap: Map<string, number>;
	    constructor(userId: any, timeConnected?: number);
	    connectedToDocument(doc: DocumentConnection): void;
	    setCurrentPage(docId: any, page: number): void;
	    getCurrentPage(docId: any): number;
	}
	class DocumentConnection {
	    documentId: any;
	    connectedUserArray: UserConnection[];
	    connectedUserMap: Map<string, UserConnection>;
	    scrollInformation?: ScrollSyncValue;
	    constructor(documentId: any);
	    isEmpty(): boolean;
	    userIsConnectedToDocument(userId: string): boolean;
	    userConnected(user: UserConnection): void;
	    userDisconnected(userId: string): void;
	    removeScrollInfo(): void;
	}
	export default class ConnectedUserMap {
	    userConnectionMap: Map<string, UserConnection>;
	    documentConnectionMap: Map<string, DocumentConnection>;
	    constructor();
	    getConnectedUsersForDocument(documentId: string): UserConnection[];
	    getUserCurrentPage(userId: string, documentId: string): number;
	    getScrollPositionForDocument(documentId: string): ScrollSyncValue;
	    setCurrentPageForUser(userId: string, documentId: string, currentPage: number): void;
	    setScrollPositionForDocument(userId: any, documentId: string, position: ScrollPosition): void;
	    connectUserToDocument(userId: string, documentId: string, pageNumber?: number): boolean;
	    disconnectUserFromDocument(userId: string, documentId: string): boolean;
	    disconnectUserFromAllDocuments(userId: any): any[];
	    disconnectFromScroll(documentId: any): boolean;
	    leaveScroll(leavingUserId: string): string[];
	    connect(userId: string): void;
	    /**
	     * Checks if a user is connected or not
	     * used to be .has()
	     */
	    isUserConnected(userId: string): boolean;
	    /**
	     * Used to be .delete()
	     */
	    disconnectUser(userId: string): void;
	    /**
	     * Used to be .keys()
	     */
	    getAllConnectedUsers(): IterableIterator<string>;
	    clear(): void;
	    hasDocumentForScroll(documentId: string): boolean;
	    cull(): void;
	}
	export {};

	export const TIMESTAMP = "__timestamp__";
	export const setTime: () => number;
	export const clearTime: () => any;
	/**
	 * Converts '__timestamp__' to a number timestamp
	 */
	export const setTimestamps: (data: any) => any;

	import { AddAnnotationVariables } from './../../collab-client/src/graphql/mutations/types/AddAnnotation';
	import { EditDocumentVariables } from './../../collab-client/src/graphql/mutations/types/EditDocument';
	import { Resolvers, Annotation as ApolloAnnotation, Document as ApolloDocument, DocumentMember as ApolloDocumentMember, AnnotationMember as ApolloAnnotationMember, User as ApolloUser, Mention as ApolloMention, DeleteResult, EditAnnotationInput, EditDocumentMemberInput, EditAnnotationMemberInput, EditMentionInput } from "./../../../types/resolvers-types";
	export { Context, UserAuth } from './index';
	export { Annotation as ApolloAnnotation, Document as ApolloDocument, DocumentMember as ApolloDocumentMember, AnnotationMember as ApolloAnnotationMember, User as ApolloUser, UserTypes, DeleteResult, EditAnnotationInput, EditDocumentMemberInput, EditAnnotationMemberInput, } from "./../../../types/resolvers-types";
	type AsyncOrSync<T> = Promise<T> | T;
	export type ApolloDatabaseUser = Omit<ApolloUser, 'documents' | '__typename'>;
	export type ApolloDatabaseDocument = Omit<ApolloDocument, 'members' | 'annotations' | 'unreadCount' | '__typename'>;
	export type ApolloDatabaseAnnotation = Omit<ApolloAnnotation, 'membership' | 'author' | 'mentions' | '__typename'> & {
	    authorId: string;
	};
	export type ApolloDatabaseAnnotationMember = Omit<ApolloAnnotationMember, '__typename' | 'user'> & {
	    userId: string;
	    annotationCreatedAt: number;
	};
	export type ApolloDatabaseDocumentMember = Omit<ApolloDocumentMember, '__typename' | 'user'> & {
	    userId: string;
	};
	export type EditAnnotationMemberUserInput = Omit<EditAnnotationMemberInput, 'lastRead'> & {
	    lastRead?: number;
	};
	export type EditDocumentMemberUserInput = Omit<EditDocumentMemberInput, 'lastRead'> & {
	    lastRead?: number;
	};
	export type ApolloDatabaseMention = Omit<ApolloMention, 'mentionedUser' | '__typename'> & {
	    userId: string;
	};
	export type AnnotationMemberCountQueryData = {
	    userId: string;
	    documentId: string;
	    since: number;
	};
	export type AnnotationCountQueryData = {
	    documentId: string;
	    since: number;
	};
	export type QueryParams = {
	    createdBefore?: number;
	    createdAfter?: number;
	    updatedBefore?: number;
	    updatedAfter?: number;
	    orderBy?: 'updatedAt' | 'createdAt';
	    orderDirection?: 'ASC' | 'DESC';
	    limit?: number;
	};
	export type AnnotationsQuery = {
	    ids?: string[];
	    documentId?: string;
	    pageNumbers?: number[];
	    inReplyTo?: string;
	    filters?: QueryParams;
	};
	export type DocumentsQuery = {
	    ids?: string[];
	    userId?: string;
	    filters?: QueryParams;
	};
	export type AnnotationMembersQuery = {
	    ids?: string[];
	    annotationId?: string;
	    userId?: string;
	    filters?: QueryParams;
	};
	export type DocumentMembersQuery = {
	    documentId?: string;
	    userId?: string;
	    ids?: string[];
	    filters?: QueryParams;
	};
	export type MentionsQuery = {
	    annotationId?: string;
	    userId?: string;
	    documentId?: string;
	    ids?: string[];
	    filters?: QueryParams;
	};
	type UserResolvers = {
	    Query: {
	        user: (id: string) => AsyncOrSync<ApolloDatabaseUser>;
	        userWithEmail: (email: string) => AsyncOrSync<ApolloDatabaseUser>;
	        annotations: (query: AnnotationsQuery) => AsyncOrSync<Array<ApolloDatabaseAnnotation>>;
	        documents: (query: DocumentsQuery) => AsyncOrSync<Array<ApolloDatabaseDocument>>;
	        annotationMembers: (query: AnnotationMembersQuery) => AsyncOrSync<Array<ApolloDatabaseAnnotationMember>>;
	        documentMembers: (query: DocumentMembersQuery) => AsyncOrSync<Array<ApolloDatabaseDocumentMember>>;
	        annotationCount: (query: AnnotationCountQueryData) => AsyncOrSync<number>;
	        annotationMemberCount: (query: AnnotationMemberCountQueryData) => AsyncOrSync<number>;
	        mentions: (query: MentionsQuery) => AsyncOrSync<Array<ApolloDatabaseMention>>;
	    };
	    Mutation: {
	        addUser: (user: ApolloDatabaseUser) => AsyncOrSync<ApolloDatabaseUser | null>;
	        addAnnotation: (annotation: AddAnnotationVariables['input']) => AsyncOrSync<ApolloDatabaseAnnotation | null>;
	        editAnnotation: (id: string, input: EditAnnotationInput) => AsyncOrSync<ApolloDatabaseAnnotation | null>;
	        deleteAnnotation: (id: string) => AsyncOrSync<DeleteResult>;
	        addDocument: (document: ApolloDatabaseDocument) => AsyncOrSync<ApolloDatabaseDocument | null>;
	        editDocument: (id: string, input: EditDocumentVariables['input']) => AsyncOrSync<ApolloDatabaseDocument | null>;
	        deleteDocument: (id: string) => AsyncOrSync<DeleteResult>;
	        addDocumentMember: (documentMember: ApolloDatabaseDocumentMember) => AsyncOrSync<ApolloDatabaseDocumentMember | null>;
	        editDocumentMember: (id: string, input: EditDocumentMemberUserInput) => AsyncOrSync<ApolloDatabaseDocumentMember | null>;
	        deleteDocumentMember: (id: string) => AsyncOrSync<DeleteResult>;
	        addAnnotationMember: (annotationMember: ApolloDatabaseAnnotationMember) => AsyncOrSync<ApolloDatabaseAnnotationMember | null>;
	        editAnnotationMember: (id: string, input: EditAnnotationMemberUserInput) => AsyncOrSync<ApolloDatabaseAnnotationMember | null>;
	        deleteAnnotationMember: (id: string) => AsyncOrSync<DeleteResult>;
	        addMention: (mention: ApolloDatabaseMention) => AsyncOrSync<ApolloDatabaseMention | null>;
	        editMention: (id: string, input: EditMentionInput) => AsyncOrSync<ApolloDatabaseMention | null>;
	        deleteMention: (id: string) => AsyncOrSync<DeleteResult>;
	    };
	};
	export const SubscriptionTypes: {
	    ANNOTATION_CHANGED: string;
	    DOCUMENT_CHANGED: string;
	    MENTION_CHANGED: string;
	    SCROLL_POSITION_CHANGED: string;
	    CONNECTED_DOC_USERS_CHANGED: string;
	};
	const makeResolvers: () => Resolvers;
	export { makeResolvers, UserResolvers };

	import { NewAnnotationInput } from "./../../../../../../types/global-graphql-types";
	export interface AddAnnotation_addAnnotation {
	    __typename: "Annotation";
	    id: string;
	    xfdf: string;
	}
	export interface AddAnnotation {
	    addAnnotation: AddAnnotation_addAnnotation;
	}
	export interface AddAnnotationVariables {
	    input: NewAnnotationInput;
	}

	export enum ChangeEventTypes {
	    ADD = "ADD",
	    DELETE = "DELETE",
	    EDIT = "EDIT",
	    INVITE = "INVITE"
	}
	export enum OrderDirections {
	    ASC = "ASC",
	    DESC = "DESC"
	}
	export enum OrderTypes {
	    createdAt = "createdAt",
	    updatedAt = "updatedAt"
	}
	export enum UserTypes {
	    ANONYMOUS = "ANONYMOUS",
	    STANDARD = "STANDARD"
	}
	export interface DeleteAnnotationMemberInput {
	    memberId?: string | null;
	    annotationId?: string | null;
	    userId?: string | null;
	}
	export interface DeleteConnectedDocUserInput {
	    documentId: string;
	    userId: string;
	}
	export interface DeleteDocumentMemberInput {
	    memberId: string;
	}
	export interface EditAnnotationInput {
	    xfdf?: string | null;
	    annotContents?: string | null;
	    pageNumber?: number | null;
	    updatedAt: any;
	}
	export interface EditConnectedDocUserInput {
	    documentId: string;
	    userId: string;
	    currentPage?: number | null;
	}
	export interface EditDocumentInput {
	    isPublic?: boolean | null;
	    name?: string | null;
	    updatedAt: any;
	}
	export interface EditMentionInput {
	    readBeforeMention?: boolean | null;
	    updatedAt: any;
	}
	export interface InvitedUserInput {
	    id?: string | null;
	    userName?: string | null;
	    email?: string | null;
	}
	export interface NewAnnotationInput {
	    id: string;
	    xfdf: string;
	    annotContents?: string | null;
	    mentionedUserIds?: string[] | null;
	    authorId?: string | null;
	    documentId: string;
	    pageNumber: number;
	    inReplyTo?: string | null;
	    createdAt: any;
	    updatedAt: any;
	}
	export interface NewAnnotationMemberInput {
	    annotationId: string;
	    documentId: string;
	    userId: string;
	    updatedAt: any;
	    createdAt: any;
	}
	export interface NewDocumentInput {
	    id?: string | null;
	    name?: string | null;
	    authorId: string;
	    isPublic?: boolean | null;
	    updatedAt: any;
	    createdAt: any;
	}
	export interface NewDocumentMemberInput {
	    documentId: string;
	    userId: string;
	    lastRead: any;
	    updatedAt: any;
	    createdAt: any;
	}
	export interface NewMentionInput {
	    userId: string;
	    annotationId: string;
	    documentId: string;
	    updatedAt: any;
	    createdAt: any;
	}
	export interface NewScrollPositionInput {
	    scrollTop?: number | null;
	    scrollHeight?: number | null;
	}
	export interface NewUserInput {
	    userName?: string | null;
	    email?: string | null;
	    type?: UserTypes | null;
	    updatedAt: any;
	    createdAt: any;
	}

	import { ApolloDatabaseUser } from './../resolvers';
	import { Document } from './Document';
	import { Context } from '../resolvers';
	import { NewUserInput, User as ApolloUser } from './../../../../types/resolvers-types';
	import { Base } from './Base';
	export class User extends Base<ApolloDatabaseUser, ApolloUser, {
	    documents: Document[];
	}> {
	    constructor(user: ApolloDatabaseUser, from: string, context: Context);
	    removeDocument(docId: string): Promise<import("./../resolvers").DeleteResult>;
	    static buildFromId(id: string, from: string, context: Context): Promise<User>;
	    static buildFromEmail(email: string, from: string, context: Context): Promise<User>;
	    static create(input: Omit<NewUserInput, 'createdAt' | 'updatedAt'>, from: string, context: Context): Promise<User>;
	}

	export const joinFrom: (incoming: string, newString: string) => string;

	import type winston from 'winston';
	import { Logging } from '../../../shared/log/logger';
	export type Maybe<T> = T | null;
	export type AsyncOrSync<T> = Promise<T> | T;
	export type Scalars = {
	    ID: string;
	    String: string;
	    Boolean: boolean;
	    Int: number;
	    Float: number;
	    Date: any;
	};
	export type CollabDBPostgreSQLOptions = {
	    host: string;
	    port: number;
	    dbName: string;
	    username: string;
	    password?: string;
	    logLevel?: Logging;
	    logTransports?: Array<winston.transport>;
	};
	export enum UserStatus {
	    Active = "ACTIVE",
	    Inactive = "INACTIVE"
	}
	export enum UserTypes {
	    Anonymous = "ANONYMOUS",
	    Standard = "STANDARD"
	}
	export type CreateUser = {
	    email: string;
	    password: string;
	    userName?: string;
	};
	export type User = {
	    id: Scalars['ID'];
	    userName?: Maybe<Scalars['String']>;
	    type?: Maybe<UserTypes>;
	    email: Scalars['String'];
	    password?: Maybe<Scalars['String']>;
	    status?: UserStatus;
	    createdAt?: Maybe<Scalars['Date']>;
	    updatedAt?: Maybe<Scalars['Date']>;
	};
	export enum QueryType {
	    Single = "SINGLE",
	    Multiple = "MULTIPLE"
	}

	import winston from 'winston';
	export enum Tags {
	    STANDARD = "STANDARD",
	    ENTITY = "ENTITY",
	    QUERY = "QUERY",
	    RESPONSE = "RESPONSE"
	}
	export type Logging = 'error' | 'warn' | 'info' | 'http' | 'verbose' | 'debug' | 'silly' | 'none';
	export const LogLevels: {
	    readonly ERROR: "error";
	    readonly WARN: "warn";
	    readonly INFO: "info";
	    readonly HTTP: "http";
	    readonly VERBOSE: "verbose";
	    readonly DEBUG: "debug";
	    readonly SILLY: "silly";
	    readonly NONE: "none";
	};
	const logger: winston.Logger;
	export const setupLogger: (logLevel: Logging, logTransports: Array<winston.transport>) => void;
	export default logger;

	import winston from 'winston';
	import { Logging } from './logger';
	export const addConsoleTransport: (logger: winston.Logger, level?: Logging) => void;
	export const addTransports: (logger: winston.Logger, transports: Array<winston.transport>) => void;

	import { PubSub } from 'apollo-server';
	import { ApolloDatabaseDocument, ApolloDatabaseDocumentMember, ApolloDatabaseUser } from './../resolvers';
	import { Document as ApolloDocument, InvitedUserInput, NewDocumentInput, NewAnnotationInput } from './../../../../types/resolvers-types';
	import { Base } from './Base';
	import { Annotation } from './Annotation';
	import { Context } from '../resolvers';
	import { DocumentMember } from './DocumentMember';
	import { AuthMethod } from '../util/permission';
	import { RequestedFields } from '../util/getRequestedFields';
	export type DocumentPublishEventOptions = {
	    markedAllAsRead?: boolean;
	};
	export class Document extends Base<ApolloDatabaseDocument, ApolloDocument, {
	    members: DocumentMember[];
	    annotations: Annotation[];
	    unreadCount: number;
	}> {
	    constructor(document: ApolloDatabaseDocument, userId: string, from: string, context: Context);
	    publishEvent(pubsub: PubSub, action: 'INVITE' | 'EDIT' | 'ADD' | 'DELETE', options?: DocumentPublishEventOptions): Promise<void>;
	    getResolvedMembers(): Promise<(ApolloDatabaseDocumentMember & {
	        user: ApolloDatabaseUser;
	    })[]>;
	    getUserMembership(userId: any): Promise<ApolloDatabaseDocumentMember>;
	    getDocumentForUser(userId: any, requestedFields: RequestedFields): Promise<Document>;
	    checkPermission(authMethods: Array<AuthMethod> | AuthMethod, context: Context): Promise<boolean>;
	    addUsers(usersInvited: InvitedUserInput[], currentUserId?: string): Promise<{
	        isSelfInvite: boolean;
	    }>;
	    static buildFromId(id: string, userId: string, from: string, context: Context): Promise<Document>;
	    static create(document: NewDocumentInput, annots: NewAnnotationInput[], usersInvited: InvitedUserInput[], from: string, context: Context): Promise<Document>;
	}

	import { GraphQLResolveInfo, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';
	export type Maybe<T> = T | null;
	export type Exact<T extends {
	    [key: string]: unknown;
	}> = {
	    [K in keyof T]: T[K];
	};
	export type RequireFields<T, K extends keyof T> = {
	    [X in Exclude<keyof T, K>]?: T[X];
	} & {
	    [P in K]-?: NonNullable<T[P]>;
	};
	/** All built-in and custom scalars, mapped to their actual values */
	export type Scalars = {
	    ID: string;
	    String: string;
	    Boolean: boolean;
	    Int: number;
	    Float: number;
	    Date: any;
	};
	export type User = {
	    __typename?: 'User';
	    id: Scalars['ID'];
	    email?: Maybe<Scalars['String']>;
	    type: UserTypes;
	    userName?: Maybe<Scalars['String']>;
	    createdAt: Scalars['Date'];
	    updatedAt: Scalars['Date'];
	    documents: Array<Document>;
	};
	export enum UserTypes {
	    Anonymous = "ANONYMOUS",
	    Standard = "STANDARD"
	}
	export enum OrderDirections {
	    Asc = "ASC",
	    Desc = "DESC"
	}
	export enum OrderTypes {
	    UpdatedAt = "updatedAt",
	    CreatedAt = "createdAt"
	}
	export type Member = {
	    id: Scalars['ID'];
	    documentId: Scalars['ID'];
	    lastRead: Scalars['Date'];
	};
	export type AnnotationMember = Member & {
	    __typename?: 'AnnotationMember';
	    id: Scalars['ID'];
	    documentId: Scalars['ID'];
	    annotationId: Scalars['ID'];
	    lastRead: Scalars['Date'];
	    createdAt: Scalars['Date'];
	    updatedAt: Scalars['Date'];
	    annotationCreatedAt: Scalars['Date'];
	};
	export type DocumentMember = Member & {
	    __typename?: 'DocumentMember';
	    id: Scalars['ID'];
	    user: User;
	    documentId: Scalars['ID'];
	    lastRead: Scalars['Date'];
	    createdAt: Scalars['Date'];
	    updatedAt: Scalars['Date'];
	};
	export type Annotation = {
	    __typename?: 'Annotation';
	    id: Scalars['ID'];
	    xfdf: Scalars['String'];
	    annotContents?: Maybe<Scalars['String']>;
	    author?: Maybe<User>;
	    documentId: Scalars['ID'];
	    pageNumber: Scalars['Int'];
	    createdAt: Scalars['Date'];
	    updatedAt: Scalars['Date'];
	    membership?: Maybe<AnnotationMember>;
	    mentions: Array<Mention>;
	    inReplyTo?: Maybe<Scalars['ID']>;
	};
	export type Document = {
	    __typename?: 'Document';
	    id: Scalars['ID'];
	    annotations: Array<Annotation>;
	    members: Array<DocumentMember>;
	    authorId: Scalars['ID'];
	    createdAt: Scalars['Date'];
	    updatedAt: Scalars['Date'];
	    isPublic?: Maybe<Scalars['Boolean']>;
	    name?: Maybe<Scalars['String']>;
	    unreadCount: Scalars['Int'];
	};
	export type DeleteResult = {
	    __typename?: 'DeleteResult';
	    id?: Maybe<Scalars['ID']>;
	    successful: Scalars['Boolean'];
	    message?: Maybe<Scalars['String']>;
	};
	export type ConnectResult = {
	    __typename?: 'ConnectResult';
	    userId?: Maybe<Scalars['ID']>;
	    documentId?: Maybe<Scalars['ID']>;
	    successful: Scalars['Boolean'];
	};
	export type Mention = {
	    __typename?: 'Mention';
	    id: Scalars['ID'];
	    annotationId: Scalars['ID'];
	    documentId: Scalars['ID'];
	    mentionedUser: User;
	    /** Use this to record if the annotation that this mention belongs to is read when the mention is created. */
	    readBeforeMention?: Maybe<Scalars['Boolean']>;
	    createdAt: Scalars['Date'];
	    updatedAt: Scalars['Date'];
	};
	export type ScrollSyncPosition = {
	    __typename?: 'ScrollSyncPosition';
	    scrollTop?: Maybe<Scalars['Int']>;
	    scrollHeight?: Maybe<Scalars['Int']>;
	};
	export type ScrollSyncResult = {
	    __typename?: 'ScrollSyncResult';
	    position?: Maybe<ScrollSyncPosition>;
	};
	export type NewScrollPositionInput = {
	    scrollTop?: Maybe<Scalars['Int']>;
	    scrollHeight?: Maybe<Scalars['Int']>;
	};
	export type NewAnnotationInput = {
	    id: Scalars['ID'];
	    xfdf: Scalars['String'];
	    annotContents?: Maybe<Scalars['String']>;
	    mentionedUserIds?: Maybe<Array<Scalars['ID']>>;
	    authorId?: Maybe<Scalars['ID']>;
	    documentId: Scalars['ID'];
	    pageNumber: Scalars['Int'];
	    inReplyTo?: Maybe<Scalars['ID']>;
	    createdAt: Scalars['Date'];
	    updatedAt: Scalars['Date'];
	};
	export type EditAnnotationInput = {
	    xfdf?: Maybe<Scalars['String']>;
	    annotContents?: Maybe<Scalars['String']>;
	    pageNumber?: Maybe<Scalars['Int']>;
	    updatedAt: Scalars['Date'];
	};
	export type NewAnnotationMemberInput = {
	    annotationId: Scalars['ID'];
	    documentId: Scalars['ID'];
	    userId: Scalars['ID'];
	    updatedAt: Scalars['Date'];
	    createdAt: Scalars['Date'];
	};
	export type EditAnnotationMemberInput = {
	    lastRead?: Maybe<Scalars['String']>;
	    updatedAt: Scalars['Date'];
	};
	export type NewDocumentMemberInput = {
	    documentId: Scalars['ID'];
	    userId: Scalars['ID'];
	    lastRead: Scalars['Date'];
	    updatedAt: Scalars['Date'];
	    createdAt: Scalars['Date'];
	};
	export type EditDocumentMemberInput = {
	    lastRead?: Maybe<Scalars['String']>;
	    updatedAt: Scalars['Date'];
	};
	export type NewDocumentInput = {
	    id?: Maybe<Scalars['ID']>;
	    name?: Maybe<Scalars['String']>;
	    authorId: Scalars['ID'];
	    isPublic?: Maybe<Scalars['Boolean']>;
	    updatedAt: Scalars['Date'];
	    createdAt: Scalars['Date'];
	};
	export type EditDocumentInput = {
	    isPublic?: Maybe<Scalars['Boolean']>;
	    name?: Maybe<Scalars['String']>;
	    updatedAt: Scalars['Date'];
	};
	export type NewUserInput = {
	    userName?: Maybe<Scalars['String']>;
	    email?: Maybe<Scalars['String']>;
	    type?: Maybe<UserTypes>;
	    updatedAt: Scalars['Date'];
	    createdAt: Scalars['Date'];
	};
	export type EditUserInput = {
	    userName?: Maybe<Scalars['String']>;
	    email?: Maybe<Scalars['String']>;
	    type?: Maybe<UserTypes>;
	    updatedAt: Scalars['Date'];
	};
	export type InvitedUserInput = {
	    id?: Maybe<Scalars['ID']>;
	    userName?: Maybe<Scalars['String']>;
	    email?: Maybe<Scalars['String']>;
	};
	export type DeleteAnnotationMemberInput = {
	    memberId?: Maybe<Scalars['ID']>;
	    annotationId?: Maybe<Scalars['ID']>;
	    userId?: Maybe<Scalars['ID']>;
	};
	export type DeleteDocumentMemberInput = {
	    memberId: Scalars['ID'];
	};
	export type NewMentionInput = {
	    userId: Scalars['ID'];
	    annotationId: Scalars['ID'];
	    documentId: Scalars['ID'];
	    updatedAt: Scalars['Date'];
	    createdAt: Scalars['Date'];
	};
	export type EditMentionInput = {
	    readBeforeMention?: Maybe<Scalars['Boolean']>;
	    updatedAt: Scalars['Date'];
	};
	export type ConnectedDocUser = {
	    __typename?: 'ConnectedDocUser';
	    userId: Scalars['ID'];
	    currentPage?: Maybe<Scalars['Int']>;
	};
	export type EditConnectedDocUserInput = {
	    documentId: Scalars['ID'];
	    userId: Scalars['ID'];
	    currentPage?: Maybe<Scalars['Int']>;
	};
	export type DeleteConnectedDocUserInput = {
	    documentId: Scalars['ID'];
	    userId: Scalars['ID'];
	};
	export type AuthUser = {
	    __typename?: 'AuthUser';
	    id: Scalars['ID'];
	    userName?: Maybe<Scalars['String']>;
	    token?: Maybe<Scalars['String']>;
	};
	export type Query = {
	    __typename?: 'Query';
	    user: User;
	    annotation?: Maybe<Annotation>;
	    annotations: Array<Annotation>;
	    document?: Maybe<Document>;
	    documents: Array<Document>;
	    session?: Maybe<AuthUser>;
	    mentions: Array<Mention>;
	    isScrollSyncAvailable: Scalars['Boolean'];
	    scrollSyncPosition?: Maybe<ScrollSyncResult>;
	    connectedDocUsers: Array<ConnectedDocUser>;
	};
	export type QueryUserArgs = {
	    id: Scalars['ID'];
	};
	export type QueryAnnotationArgs = {
	    id: Scalars['ID'];
	};
	export type QueryAnnotationsArgs = {
	    documentId: Scalars['ID'];
	};
	export type QueryDocumentArgs = {
	    id: Scalars['ID'];
	};
	export type QueryDocumentsArgs = {
	    userId: Scalars['ID'];
	    limit: Scalars['Int'];
	    before?: Maybe<Scalars['Date']>;
	    orderBy?: Maybe<OrderTypes>;
	    orderDirection?: Maybe<OrderDirections>;
	};
	export type QueryMentionsArgs = {
	    annotationId: Scalars['ID'];
	};
	export type QueryIsScrollSyncAvailableArgs = {
	    userId: Scalars['ID'];
	    documentId: Scalars['ID'];
	};
	export type QueryScrollSyncPositionArgs = {
	    documentId: Scalars['ID'];
	};
	export type QueryConnectedDocUsersArgs = {
	    documentId: Scalars['ID'];
	};
	export type Mutation = {
	    __typename?: 'Mutation';
	    addAnnotation: Annotation;
	    editAnnotation: Annotation;
	    deleteAnnotation: DeleteResult;
	    addAnnotationMember: AnnotationMember;
	    editAnnotationMember: AnnotationMember;
	    updateAnnotationMemberLastRead: UpdateAnnotationMemberLastReadPayload;
	    deleteAnnotationMember: DeleteResult;
	    addDocument: Document;
	    inviteUsersToDocument: Document;
	    editDocument: Document;
	    deleteDocument: DeleteResult;
	    addDocumentMember: DocumentMember;
	    editDocumentMember: DocumentMember;
	    deleteDocumentMember: DeleteResult;
	    addUser: User;
	    login: AuthPayload;
	    loginAnonymous: AuthPayload;
	    endSession?: Maybe<Scalars['Boolean']>;
	    addMention: Mention;
	    editMention: Mention;
	    deleteMention: DeleteResult;
	    markAllAsRead: Document;
	    editScrollSync: ScrollSyncResult;
	    deleteScrollSync: DeleteResult;
	    connectUserToDocument: ConnectResult;
	    editConnectedDocUser?: Maybe<Array<Maybe<ConnectedDocUser>>>;
	    deleteConnectedDocUser: DeleteResult;
	};
	export type MutationAddAnnotationArgs = {
	    input: NewAnnotationInput;
	};
	export type MutationEditAnnotationArgs = {
	    id: Scalars['ID'];
	    input: EditAnnotationInput;
	};
	export type MutationDeleteAnnotationArgs = {
	    id: Scalars['ID'];
	};
	export type MutationAddAnnotationMemberArgs = {
	    input: NewAnnotationMemberInput;
	};
	export type MutationEditAnnotationMemberArgs = {
	    annotationId: Scalars['ID'];
	    userId: Scalars['ID'];
	    memberId?: Maybe<Scalars['ID']>;
	    input?: Maybe<EditAnnotationMemberInput>;
	};
	export type MutationUpdateAnnotationMemberLastReadArgs = {
	    annotationId: Scalars['ID'];
	    userId: Scalars['ID'];
	};
	export type MutationDeleteAnnotationMemberArgs = {
	    input: DeleteAnnotationMemberInput;
	};
	export type MutationAddDocumentArgs = {
	    document: NewDocumentInput;
	    annotations?: Maybe<Array<NewAnnotationInput>>;
	    usersInvited?: Maybe<Array<InvitedUserInput>>;
	};
	export type MutationInviteUsersToDocumentArgs = {
	    id: Scalars['ID'];
	    usersInvited?: Maybe<Array<InvitedUserInput>>;
	};
	export type MutationEditDocumentArgs = {
	    id: Scalars['ID'];
	    input?: Maybe<EditDocumentInput>;
	};
	export type MutationDeleteDocumentArgs = {
	    id: Scalars['ID'];
	};
	export type MutationAddDocumentMemberArgs = {
	    input: NewDocumentMemberInput;
	};
	export type MutationEditDocumentMemberArgs = {
	    documentId: Scalars['ID'];
	    userId: Scalars['ID'];
	    memberId?: Maybe<Scalars['ID']>;
	    input?: Maybe<EditDocumentMemberInput>;
	};
	export type MutationDeleteDocumentMemberArgs = {
	    input: DeleteDocumentMemberInput;
	};
	export type MutationAddUserArgs = {
	    input: NewUserInput;
	};
	export type MutationLoginArgs = {
	    email?: Maybe<Scalars['String']>;
	    password?: Maybe<Scalars['String']>;
	    token?: Maybe<Scalars['String']>;
	};
	export type MutationLoginAnonymousArgs = {
	    userName?: Maybe<Scalars['String']>;
	};
	export type MutationAddMentionArgs = {
	    input?: Maybe<NewMentionInput>;
	};
	export type MutationEditMentionArgs = {
	    userId: Scalars['ID'];
	    annotationId: Scalars['ID'];
	    input?: Maybe<EditMentionInput>;
	};
	export type MutationDeleteMentionArgs = {
	    userId: Scalars['ID'];
	    annotationId: Scalars['ID'];
	};
	export type MutationMarkAllAsReadArgs = {
	    documentId?: Maybe<Scalars['ID']>;
	};
	export type MutationEditScrollSyncArgs = {
	    documentId: Scalars['ID'];
	    userId: Scalars['ID'];
	    position: NewScrollPositionInput;
	};
	export type MutationDeleteScrollSyncArgs = {
	    documentId: Scalars['ID'];
	};
	export type MutationConnectUserToDocumentArgs = {
	    documentId: Scalars['ID'];
	    userId: Scalars['ID'];
	};
	export type MutationEditConnectedDocUserArgs = {
	    input: EditConnectedDocUserInput;
	};
	export type MutationDeleteConnectedDocUserArgs = {
	    input: DeleteConnectedDocUserInput;
	};
	export enum ChangeEventTypes {
	    Add = "ADD",
	    Edit = "EDIT",
	    Delete = "DELETE",
	    Invite = "INVITE"
	}
	export type AnnotationSubscriptionEvent = {
	    __typename?: 'AnnotationSubscriptionEvent';
	    annotation: Annotation;
	    document?: Maybe<Document>;
	    action: ChangeEventTypes;
	    mentionedCurrentUser?: Maybe<Scalars['Boolean']>;
	};
	export type DocumentSubscriptionEvent = {
	    __typename?: 'DocumentSubscriptionEvent';
	    document: Document;
	    markedAllAsRead?: Maybe<Scalars['Boolean']>;
	    action: ChangeEventTypes;
	};
	export type MentionSubscriptionEvent = {
	    __typename?: 'MentionSubscriptionEvent';
	    mention: Mention;
	    action: ChangeEventTypes;
	};
	export type ScrollPositionSubscriptionEvent = {
	    __typename?: 'ScrollPositionSubscriptionEvent';
	    documentId: Scalars['ID'];
	    position?: Maybe<ScrollSyncPosition>;
	    action: ChangeEventTypes;
	};
	export type ConnectedDocUsersSubscriptionEvent = {
	    __typename?: 'ConnectedDocUsersSubscriptionEvent';
	    documentId: Scalars['ID'];
	    connectedDocUsers: Array<ConnectedDocUser>;
	    action: ChangeEventTypes;
	};
	export type Subscription = {
	    __typename?: 'Subscription';
	    annotationChanged: AnnotationSubscriptionEvent;
	    documentChanged: DocumentSubscriptionEvent;
	    mentionChanged: MentionSubscriptionEvent;
	    scrollPositionChanged: ScrollPositionSubscriptionEvent;
	    connectedDocUsersChanged: ConnectedDocUsersSubscriptionEvent;
	};
	export type SubscriptionAnnotationChangedArgs = {
	    userId: Scalars['ID'];
	};
	export type SubscriptionDocumentChangedArgs = {
	    userId: Scalars['ID'];
	};
	export type SubscriptionMentionChangedArgs = {
	    userId: Scalars['ID'];
	};
	export type SubscriptionScrollPositionChangedArgs = {
	    docId: Scalars['ID'];
	};
	export type SubscriptionConnectedDocUsersChangedArgs = {
	    docId: Scalars['ID'];
	};
	export type AuthPayload = {
	    __typename?: 'AuthPayload';
	    user?: Maybe<User>;
	};
	export type IgnoreMembership = {
	    __typename?: 'IgnoreMembership';
	    message?: Maybe<Scalars['String']>;
	    annotationId: Scalars['ID'];
	};
	export type AnnotationNotFound = {
	    __typename?: 'AnnotationNotFound';
	    message?: Maybe<Scalars['String']>;
	    annotationId: Scalars['ID'];
	};
	export type UpdateAnnotationMemberLastReadPayload = AnnotationMember | AnnotationNotFound | IgnoreMembership;
	export type WithIndex<TObject> = TObject & Record<string, any>;
	export type ResolversObject<TObject> = WithIndex<TObject>;
	export type ResolverTypeWrapper<T> = Promise<T> | T;
	export type LegacyStitchingResolver<TResult, TParent, TContext, TArgs> = {
	    fragment: string;
	    resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
	};
	export type NewStitchingResolver<TResult, TParent, TContext, TArgs> = {
	    selectionSet: string;
	    resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
	};
	export type StitchingResolver<TResult, TParent, TContext, TArgs> = LegacyStitchingResolver<TResult, TParent, TContext, TArgs> | NewStitchingResolver<TResult, TParent, TContext, TArgs>;
	export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> = ResolverFn<TResult, TParent, TContext, TArgs> | StitchingResolver<TResult, TParent, TContext, TArgs>;
	export type ResolverFn<TResult, TParent, TContext, TArgs> = (parent: TParent, args: TArgs, context: TContext, info: GraphQLResolveInfo) => Promise<TResult> | TResult;
	export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (parent: TParent, args: TArgs, context: TContext, info: GraphQLResolveInfo) => AsyncIterator<TResult> | Promise<AsyncIterator<TResult>>;
	export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (parent: TParent, args: TArgs, context: TContext, info: GraphQLResolveInfo) => TResult | Promise<TResult>;
	export interface SubscriptionSubscriberObject<TResult, TKey extends string, TParent, TContext, TArgs> {
	    subscribe: SubscriptionSubscribeFn<{
	        [key in TKey]: TResult;
	    }, TParent, TContext, TArgs>;
	    resolve?: SubscriptionResolveFn<TResult, {
	        [key in TKey]: TResult;
	    }, TContext, TArgs>;
	}
	export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
	    subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
	    resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
	}
	export type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> = SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs> | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;
	export type SubscriptionResolver<TResult, TKey extends string, TParent = {}, TContext = {}, TArgs = {}> = ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>) | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;
	export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (parent: TParent, context: TContext, info: GraphQLResolveInfo) => Maybe<TTypes> | Promise<Maybe<TTypes>>;
	export type IsTypeOfResolverFn<T = {}> = (obj: T, info: GraphQLResolveInfo) => boolean | Promise<boolean>;
	export type NextResolverFn<T> = () => Promise<T>;
	export type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (next: NextResolverFn<TResult>, parent: TParent, args: TArgs, context: TContext, info: GraphQLResolveInfo) => TResult | Promise<TResult>;
	/** Mapping between all available schema types and the resolvers types */
	export type ResolversTypes = ResolversObject<{
	    Date: ResolverTypeWrapper<Scalars['Date']>;
	    User: ResolverTypeWrapper<User>;
	    ID: ResolverTypeWrapper<Scalars['ID']>;
	    String: ResolverTypeWrapper<Scalars['String']>;
	    UserTypes: UserTypes;
	    OrderDirections: OrderDirections;
	    OrderTypes: OrderTypes;
	    Member: ResolversTypes['AnnotationMember'] | ResolversTypes['DocumentMember'];
	    AnnotationMember: ResolverTypeWrapper<AnnotationMember>;
	    DocumentMember: ResolverTypeWrapper<DocumentMember>;
	    Annotation: ResolverTypeWrapper<Annotation>;
	    Int: ResolverTypeWrapper<Scalars['Int']>;
	    Document: ResolverTypeWrapper<Document>;
	    Boolean: ResolverTypeWrapper<Scalars['Boolean']>;
	    DeleteResult: ResolverTypeWrapper<DeleteResult>;
	    ConnectResult: ResolverTypeWrapper<ConnectResult>;
	    Mention: ResolverTypeWrapper<Mention>;
	    ScrollSyncPosition: ResolverTypeWrapper<ScrollSyncPosition>;
	    ScrollSyncResult: ResolverTypeWrapper<ScrollSyncResult>;
	    NewScrollPositionInput: NewScrollPositionInput;
	    NewAnnotationInput: NewAnnotationInput;
	    EditAnnotationInput: EditAnnotationInput;
	    NewAnnotationMemberInput: NewAnnotationMemberInput;
	    EditAnnotationMemberInput: EditAnnotationMemberInput;
	    NewDocumentMemberInput: NewDocumentMemberInput;
	    EditDocumentMemberInput: EditDocumentMemberInput;
	    NewDocumentInput: NewDocumentInput;
	    EditDocumentInput: EditDocumentInput;
	    NewUserInput: NewUserInput;
	    EditUserInput: EditUserInput;
	    InvitedUserInput: InvitedUserInput;
	    DeleteAnnotationMemberInput: DeleteAnnotationMemberInput;
	    DeleteDocumentMemberInput: DeleteDocumentMemberInput;
	    NewMentionInput: NewMentionInput;
	    EditMentionInput: EditMentionInput;
	    ConnectedDocUser: ResolverTypeWrapper<ConnectedDocUser>;
	    EditConnectedDocUserInput: EditConnectedDocUserInput;
	    DeleteConnectedDocUserInput: DeleteConnectedDocUserInput;
	    AuthUser: ResolverTypeWrapper<AuthUser>;
	    Query: ResolverTypeWrapper<{}>;
	    Mutation: ResolverTypeWrapper<{}>;
	    ChangeEventTypes: ChangeEventTypes;
	    AnnotationSubscriptionEvent: ResolverTypeWrapper<AnnotationSubscriptionEvent>;
	    DocumentSubscriptionEvent: ResolverTypeWrapper<DocumentSubscriptionEvent>;
	    MentionSubscriptionEvent: ResolverTypeWrapper<MentionSubscriptionEvent>;
	    ScrollPositionSubscriptionEvent: ResolverTypeWrapper<ScrollPositionSubscriptionEvent>;
	    ConnectedDocUsersSubscriptionEvent: ResolverTypeWrapper<ConnectedDocUsersSubscriptionEvent>;
	    Subscription: ResolverTypeWrapper<{}>;
	    AuthPayload: ResolverTypeWrapper<AuthPayload>;
	    IgnoreMembership: ResolverTypeWrapper<IgnoreMembership>;
	    AnnotationNotFound: ResolverTypeWrapper<AnnotationNotFound>;
	    UpdateAnnotationMemberLastReadPayload: ResolversTypes['AnnotationMember'] | ResolversTypes['AnnotationNotFound'] | ResolversTypes['IgnoreMembership'];
	}>;
	/** Mapping between all available schema types and the resolvers parents */
	export type ResolversParentTypes = ResolversObject<{
	    Date: Scalars['Date'];
	    User: User;
	    ID: Scalars['ID'];
	    String: Scalars['String'];
	    Member: ResolversParentTypes['AnnotationMember'] | ResolversParentTypes['DocumentMember'];
	    AnnotationMember: AnnotationMember;
	    DocumentMember: DocumentMember;
	    Annotation: Annotation;
	    Int: Scalars['Int'];
	    Document: Document;
	    Boolean: Scalars['Boolean'];
	    DeleteResult: DeleteResult;
	    ConnectResult: ConnectResult;
	    Mention: Mention;
	    ScrollSyncPosition: ScrollSyncPosition;
	    ScrollSyncResult: ScrollSyncResult;
	    NewScrollPositionInput: NewScrollPositionInput;
	    NewAnnotationInput: NewAnnotationInput;
	    EditAnnotationInput: EditAnnotationInput;
	    NewAnnotationMemberInput: NewAnnotationMemberInput;
	    EditAnnotationMemberInput: EditAnnotationMemberInput;
	    NewDocumentMemberInput: NewDocumentMemberInput;
	    EditDocumentMemberInput: EditDocumentMemberInput;
	    NewDocumentInput: NewDocumentInput;
	    EditDocumentInput: EditDocumentInput;
	    NewUserInput: NewUserInput;
	    EditUserInput: EditUserInput;
	    InvitedUserInput: InvitedUserInput;
	    DeleteAnnotationMemberInput: DeleteAnnotationMemberInput;
	    DeleteDocumentMemberInput: DeleteDocumentMemberInput;
	    NewMentionInput: NewMentionInput;
	    EditMentionInput: EditMentionInput;
	    ConnectedDocUser: ConnectedDocUser;
	    EditConnectedDocUserInput: EditConnectedDocUserInput;
	    DeleteConnectedDocUserInput: DeleteConnectedDocUserInput;
	    AuthUser: AuthUser;
	    Query: {};
	    Mutation: {};
	    AnnotationSubscriptionEvent: AnnotationSubscriptionEvent;
	    DocumentSubscriptionEvent: DocumentSubscriptionEvent;
	    MentionSubscriptionEvent: MentionSubscriptionEvent;
	    ScrollPositionSubscriptionEvent: ScrollPositionSubscriptionEvent;
	    ConnectedDocUsersSubscriptionEvent: ConnectedDocUsersSubscriptionEvent;
	    Subscription: {};
	    AuthPayload: AuthPayload;
	    IgnoreMembership: IgnoreMembership;
	    AnnotationNotFound: AnnotationNotFound;
	    UpdateAnnotationMemberLastReadPayload: ResolversParentTypes['AnnotationMember'] | ResolversParentTypes['AnnotationNotFound'] | ResolversParentTypes['IgnoreMembership'];
	}>;
	export interface DateScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Date'], any> {
	    name: 'Date';
	}
	export type UserResolvers<ContextType = any, ParentType extends ResolversParentTypes['User'] = ResolversParentTypes['User']> = ResolversObject<{
	    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
	    email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
	    type?: Resolver<ResolversTypes['UserTypes'], ParentType, ContextType>;
	    userName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
	    createdAt?: Resolver<ResolversTypes['Date'], ParentType, ContextType>;
	    updatedAt?: Resolver<ResolversTypes['Date'], ParentType, ContextType>;
	    documents?: Resolver<Array<ResolversTypes['Document']>, ParentType, ContextType>;
	    __isTypeOf?: IsTypeOfResolverFn<ParentType>;
	}>;
	export type MemberResolvers<ContextType = any, ParentType extends ResolversParentTypes['Member'] = ResolversParentTypes['Member']> = ResolversObject<{
	    __resolveType: TypeResolveFn<'AnnotationMember' | 'DocumentMember', ParentType, ContextType>;
	    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
	    documentId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
	    lastRead?: Resolver<ResolversTypes['Date'], ParentType, ContextType>;
	}>;
	export type AnnotationMemberResolvers<ContextType = any, ParentType extends ResolversParentTypes['AnnotationMember'] = ResolversParentTypes['AnnotationMember']> = ResolversObject<{
	    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
	    documentId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
	    annotationId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
	    lastRead?: Resolver<ResolversTypes['Date'], ParentType, ContextType>;
	    createdAt?: Resolver<ResolversTypes['Date'], ParentType, ContextType>;
	    updatedAt?: Resolver<ResolversTypes['Date'], ParentType, ContextType>;
	    annotationCreatedAt?: Resolver<ResolversTypes['Date'], ParentType, ContextType>;
	    __isTypeOf?: IsTypeOfResolverFn<ParentType>;
	}>;
	export type DocumentMemberResolvers<ContextType = any, ParentType extends ResolversParentTypes['DocumentMember'] = ResolversParentTypes['DocumentMember']> = ResolversObject<{
	    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
	    user?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
	    documentId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
	    lastRead?: Resolver<ResolversTypes['Date'], ParentType, ContextType>;
	    createdAt?: Resolver<ResolversTypes['Date'], ParentType, ContextType>;
	    updatedAt?: Resolver<ResolversTypes['Date'], ParentType, ContextType>;
	    __isTypeOf?: IsTypeOfResolverFn<ParentType>;
	}>;
	export type AnnotationResolvers<ContextType = any, ParentType extends ResolversParentTypes['Annotation'] = ResolversParentTypes['Annotation']> = ResolversObject<{
	    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
	    xfdf?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
	    annotContents?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
	    author?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
	    documentId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
	    pageNumber?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
	    createdAt?: Resolver<ResolversTypes['Date'], ParentType, ContextType>;
	    updatedAt?: Resolver<ResolversTypes['Date'], ParentType, ContextType>;
	    membership?: Resolver<Maybe<ResolversTypes['AnnotationMember']>, ParentType, ContextType>;
	    mentions?: Resolver<Array<ResolversTypes['Mention']>, ParentType, ContextType>;
	    inReplyTo?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
	    __isTypeOf?: IsTypeOfResolverFn<ParentType>;
	}>;
	export type DocumentResolvers<ContextType = any, ParentType extends ResolversParentTypes['Document'] = ResolversParentTypes['Document']> = ResolversObject<{
	    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
	    annotations?: Resolver<Array<ResolversTypes['Annotation']>, ParentType, ContextType>;
	    members?: Resolver<Array<ResolversTypes['DocumentMember']>, ParentType, ContextType>;
	    authorId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
	    createdAt?: Resolver<ResolversTypes['Date'], ParentType, ContextType>;
	    updatedAt?: Resolver<ResolversTypes['Date'], ParentType, ContextType>;
	    isPublic?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
	    name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
	    unreadCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
	    __isTypeOf?: IsTypeOfResolverFn<ParentType>;
	}>;
	export type DeleteResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteResult'] = ResolversParentTypes['DeleteResult']> = ResolversObject<{
	    id?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
	    successful?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
	    message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
	    __isTypeOf?: IsTypeOfResolverFn<ParentType>;
	}>;
	export type ConnectResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['ConnectResult'] = ResolversParentTypes['ConnectResult']> = ResolversObject<{
	    userId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
	    documentId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
	    successful?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
	    __isTypeOf?: IsTypeOfResolverFn<ParentType>;
	}>;
	export type MentionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Mention'] = ResolversParentTypes['Mention']> = ResolversObject<{
	    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
	    annotationId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
	    documentId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
	    mentionedUser?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
	    readBeforeMention?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
	    createdAt?: Resolver<ResolversTypes['Date'], ParentType, ContextType>;
	    updatedAt?: Resolver<ResolversTypes['Date'], ParentType, ContextType>;
	    __isTypeOf?: IsTypeOfResolverFn<ParentType>;
	}>;
	export type ScrollSyncPositionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ScrollSyncPosition'] = ResolversParentTypes['ScrollSyncPosition']> = ResolversObject<{
	    scrollTop?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
	    scrollHeight?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
	    __isTypeOf?: IsTypeOfResolverFn<ParentType>;
	}>;
	export type ScrollSyncResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['ScrollSyncResult'] = ResolversParentTypes['ScrollSyncResult']> = ResolversObject<{
	    position?: Resolver<Maybe<ResolversTypes['ScrollSyncPosition']>, ParentType, ContextType>;
	    __isTypeOf?: IsTypeOfResolverFn<ParentType>;
	}>;
	export type ConnectedDocUserResolvers<ContextType = any, ParentType extends ResolversParentTypes['ConnectedDocUser'] = ResolversParentTypes['ConnectedDocUser']> = ResolversObject<{
	    userId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
	    currentPage?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
	    __isTypeOf?: IsTypeOfResolverFn<ParentType>;
	}>;
	export type AuthUserResolvers<ContextType = any, ParentType extends ResolversParentTypes['AuthUser'] = ResolversParentTypes['AuthUser']> = ResolversObject<{
	    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
	    userName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
	    token?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
	    __isTypeOf?: IsTypeOfResolverFn<ParentType>;
	}>;
	export type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = ResolversObject<{
	    user?: Resolver<ResolversTypes['User'], ParentType, ContextType, RequireFields<QueryUserArgs, 'id'>>;
	    annotation?: Resolver<Maybe<ResolversTypes['Annotation']>, ParentType, ContextType, RequireFields<QueryAnnotationArgs, 'id'>>;
	    annotations?: Resolver<Array<ResolversTypes['Annotation']>, ParentType, ContextType, RequireFields<QueryAnnotationsArgs, 'documentId'>>;
	    document?: Resolver<Maybe<ResolversTypes['Document']>, ParentType, ContextType, RequireFields<QueryDocumentArgs, 'id'>>;
	    documents?: Resolver<Array<ResolversTypes['Document']>, ParentType, ContextType, RequireFields<QueryDocumentsArgs, 'userId' | 'limit'>>;
	    session?: Resolver<Maybe<ResolversTypes['AuthUser']>, ParentType, ContextType>;
	    mentions?: Resolver<Array<ResolversTypes['Mention']>, ParentType, ContextType, RequireFields<QueryMentionsArgs, 'annotationId'>>;
	    isScrollSyncAvailable?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType, RequireFields<QueryIsScrollSyncAvailableArgs, 'userId' | 'documentId'>>;
	    scrollSyncPosition?: Resolver<Maybe<ResolversTypes['ScrollSyncResult']>, ParentType, ContextType, RequireFields<QueryScrollSyncPositionArgs, 'documentId'>>;
	    connectedDocUsers?: Resolver<Array<ResolversTypes['ConnectedDocUser']>, ParentType, ContextType, RequireFields<QueryConnectedDocUsersArgs, 'documentId'>>;
	}>;
	export type MutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['Mutation'] = ResolversParentTypes['Mutation']> = ResolversObject<{
	    addAnnotation?: Resolver<ResolversTypes['Annotation'], ParentType, ContextType, RequireFields<MutationAddAnnotationArgs, 'input'>>;
	    editAnnotation?: Resolver<ResolversTypes['Annotation'], ParentType, ContextType, RequireFields<MutationEditAnnotationArgs, 'id' | 'input'>>;
	    deleteAnnotation?: Resolver<ResolversTypes['DeleteResult'], ParentType, ContextType, RequireFields<MutationDeleteAnnotationArgs, 'id'>>;
	    addAnnotationMember?: Resolver<ResolversTypes['AnnotationMember'], ParentType, ContextType, RequireFields<MutationAddAnnotationMemberArgs, 'input'>>;
	    editAnnotationMember?: Resolver<ResolversTypes['AnnotationMember'], ParentType, ContextType, RequireFields<MutationEditAnnotationMemberArgs, 'annotationId' | 'userId'>>;
	    updateAnnotationMemberLastRead?: Resolver<ResolversTypes['UpdateAnnotationMemberLastReadPayload'], ParentType, ContextType, RequireFields<MutationUpdateAnnotationMemberLastReadArgs, 'annotationId' | 'userId'>>;
	    deleteAnnotationMember?: Resolver<ResolversTypes['DeleteResult'], ParentType, ContextType, RequireFields<MutationDeleteAnnotationMemberArgs, 'input'>>;
	    addDocument?: Resolver<ResolversTypes['Document'], ParentType, ContextType, RequireFields<MutationAddDocumentArgs, 'document'>>;
	    inviteUsersToDocument?: Resolver<ResolversTypes['Document'], ParentType, ContextType, RequireFields<MutationInviteUsersToDocumentArgs, 'id'>>;
	    editDocument?: Resolver<ResolversTypes['Document'], ParentType, ContextType, RequireFields<MutationEditDocumentArgs, 'id'>>;
	    deleteDocument?: Resolver<ResolversTypes['DeleteResult'], ParentType, ContextType, RequireFields<MutationDeleteDocumentArgs, 'id'>>;
	    addDocumentMember?: Resolver<ResolversTypes['DocumentMember'], ParentType, ContextType, RequireFields<MutationAddDocumentMemberArgs, 'input'>>;
	    editDocumentMember?: Resolver<ResolversTypes['DocumentMember'], ParentType, ContextType, RequireFields<MutationEditDocumentMemberArgs, 'documentId' | 'userId'>>;
	    deleteDocumentMember?: Resolver<ResolversTypes['DeleteResult'], ParentType, ContextType, RequireFields<MutationDeleteDocumentMemberArgs, 'input'>>;
	    addUser?: Resolver<ResolversTypes['User'], ParentType, ContextType, RequireFields<MutationAddUserArgs, 'input'>>;
	    login?: Resolver<ResolversTypes['AuthPayload'], ParentType, ContextType, RequireFields<MutationLoginArgs, never>>;
	    loginAnonymous?: Resolver<ResolversTypes['AuthPayload'], ParentType, ContextType, RequireFields<MutationLoginAnonymousArgs, never>>;
	    endSession?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
	    addMention?: Resolver<ResolversTypes['Mention'], ParentType, ContextType, RequireFields<MutationAddMentionArgs, never>>;
	    editMention?: Resolver<ResolversTypes['Mention'], ParentType, ContextType, RequireFields<MutationEditMentionArgs, 'userId' | 'annotationId'>>;
	    deleteMention?: Resolver<ResolversTypes['DeleteResult'], ParentType, ContextType, RequireFields<MutationDeleteMentionArgs, 'userId' | 'annotationId'>>;
	    markAllAsRead?: Resolver<ResolversTypes['Document'], ParentType, ContextType, RequireFields<MutationMarkAllAsReadArgs, never>>;
	    editScrollSync?: Resolver<ResolversTypes['ScrollSyncResult'], ParentType, ContextType, RequireFields<MutationEditScrollSyncArgs, 'documentId' | 'userId' | 'position'>>;
	    deleteScrollSync?: Resolver<ResolversTypes['DeleteResult'], ParentType, ContextType, RequireFields<MutationDeleteScrollSyncArgs, 'documentId'>>;
	    connectUserToDocument?: Resolver<ResolversTypes['ConnectResult'], ParentType, ContextType, RequireFields<MutationConnectUserToDocumentArgs, 'documentId' | 'userId'>>;
	    editConnectedDocUser?: Resolver<Maybe<Array<Maybe<ResolversTypes['ConnectedDocUser']>>>, ParentType, ContextType, RequireFields<MutationEditConnectedDocUserArgs, 'input'>>;
	    deleteConnectedDocUser?: Resolver<ResolversTypes['DeleteResult'], ParentType, ContextType, RequireFields<MutationDeleteConnectedDocUserArgs, 'input'>>;
	}>;
	export type AnnotationSubscriptionEventResolvers<ContextType = any, ParentType extends ResolversParentTypes['AnnotationSubscriptionEvent'] = ResolversParentTypes['AnnotationSubscriptionEvent']> = ResolversObject<{
	    annotation?: Resolver<ResolversTypes['Annotation'], ParentType, ContextType>;
	    document?: Resolver<Maybe<ResolversTypes['Document']>, ParentType, ContextType>;
	    action?: Resolver<ResolversTypes['ChangeEventTypes'], ParentType, ContextType>;
	    mentionedCurrentUser?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
	    __isTypeOf?: IsTypeOfResolverFn<ParentType>;
	}>;
	export type DocumentSubscriptionEventResolvers<ContextType = any, ParentType extends ResolversParentTypes['DocumentSubscriptionEvent'] = ResolversParentTypes['DocumentSubscriptionEvent']> = ResolversObject<{
	    document?: Resolver<ResolversTypes['Document'], ParentType, ContextType>;
	    markedAllAsRead?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
	    action?: Resolver<ResolversTypes['ChangeEventTypes'], ParentType, ContextType>;
	    __isTypeOf?: IsTypeOfResolverFn<ParentType>;
	}>;
	export type MentionSubscriptionEventResolvers<ContextType = any, ParentType extends ResolversParentTypes['MentionSubscriptionEvent'] = ResolversParentTypes['MentionSubscriptionEvent']> = ResolversObject<{
	    mention?: Resolver<ResolversTypes['Mention'], ParentType, ContextType>;
	    action?: Resolver<ResolversTypes['ChangeEventTypes'], ParentType, ContextType>;
	    __isTypeOf?: IsTypeOfResolverFn<ParentType>;
	}>;
	export type ScrollPositionSubscriptionEventResolvers<ContextType = any, ParentType extends ResolversParentTypes['ScrollPositionSubscriptionEvent'] = ResolversParentTypes['ScrollPositionSubscriptionEvent']> = ResolversObject<{
	    documentId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
	    position?: Resolver<Maybe<ResolversTypes['ScrollSyncPosition']>, ParentType, ContextType>;
	    action?: Resolver<ResolversTypes['ChangeEventTypes'], ParentType, ContextType>;
	    __isTypeOf?: IsTypeOfResolverFn<ParentType>;
	}>;
	export type ConnectedDocUsersSubscriptionEventResolvers<ContextType = any, ParentType extends ResolversParentTypes['ConnectedDocUsersSubscriptionEvent'] = ResolversParentTypes['ConnectedDocUsersSubscriptionEvent']> = ResolversObject<{
	    documentId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
	    connectedDocUsers?: Resolver<Array<ResolversTypes['ConnectedDocUser']>, ParentType, ContextType>;
	    action?: Resolver<ResolversTypes['ChangeEventTypes'], ParentType, ContextType>;
	    __isTypeOf?: IsTypeOfResolverFn<ParentType>;
	}>;
	export type SubscriptionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Subscription'] = ResolversParentTypes['Subscription']> = ResolversObject<{
	    annotationChanged?: SubscriptionResolver<ResolversTypes['AnnotationSubscriptionEvent'], "annotationChanged", ParentType, ContextType, RequireFields<SubscriptionAnnotationChangedArgs, 'userId'>>;
	    documentChanged?: SubscriptionResolver<ResolversTypes['DocumentSubscriptionEvent'], "documentChanged", ParentType, ContextType, RequireFields<SubscriptionDocumentChangedArgs, 'userId'>>;
	    mentionChanged?: SubscriptionResolver<ResolversTypes['MentionSubscriptionEvent'], "mentionChanged", ParentType, ContextType, RequireFields<SubscriptionMentionChangedArgs, 'userId'>>;
	    scrollPositionChanged?: SubscriptionResolver<ResolversTypes['ScrollPositionSubscriptionEvent'], "scrollPositionChanged", ParentType, ContextType, RequireFields<SubscriptionScrollPositionChangedArgs, 'docId'>>;
	    connectedDocUsersChanged?: SubscriptionResolver<ResolversTypes['ConnectedDocUsersSubscriptionEvent'], "connectedDocUsersChanged", ParentType, ContextType, RequireFields<SubscriptionConnectedDocUsersChangedArgs, 'docId'>>;
	}>;
	export type AuthPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['AuthPayload'] = ResolversParentTypes['AuthPayload']> = ResolversObject<{
	    user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
	    __isTypeOf?: IsTypeOfResolverFn<ParentType>;
	}>;
	export type IgnoreMembershipResolvers<ContextType = any, ParentType extends ResolversParentTypes['IgnoreMembership'] = ResolversParentTypes['IgnoreMembership']> = ResolversObject<{
	    message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
	    annotationId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
	    __isTypeOf?: IsTypeOfResolverFn<ParentType>;
	}>;
	export type AnnotationNotFoundResolvers<ContextType = any, ParentType extends ResolversParentTypes['AnnotationNotFound'] = ResolversParentTypes['AnnotationNotFound']> = ResolversObject<{
	    message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
	    annotationId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
	    __isTypeOf?: IsTypeOfResolverFn<ParentType>;
	}>;
	export type UpdateAnnotationMemberLastReadPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateAnnotationMemberLastReadPayload'] = ResolversParentTypes['UpdateAnnotationMemberLastReadPayload']> = ResolversObject<{
	    __resolveType: TypeResolveFn<'AnnotationMember' | 'AnnotationNotFound' | 'IgnoreMembership', ParentType, ContextType>;
	}>;
	export type Resolvers<ContextType = any> = ResolversObject<{
	    Date?: GraphQLScalarType;
	    User?: UserResolvers<ContextType>;
	    Member?: MemberResolvers<ContextType>;
	    AnnotationMember?: AnnotationMemberResolvers<ContextType>;
	    DocumentMember?: DocumentMemberResolvers<ContextType>;
	    Annotation?: AnnotationResolvers<ContextType>;
	    Document?: DocumentResolvers<ContextType>;
	    DeleteResult?: DeleteResultResolvers<ContextType>;
	    ConnectResult?: ConnectResultResolvers<ContextType>;
	    Mention?: MentionResolvers<ContextType>;
	    ScrollSyncPosition?: ScrollSyncPositionResolvers<ContextType>;
	    ScrollSyncResult?: ScrollSyncResultResolvers<ContextType>;
	    ConnectedDocUser?: ConnectedDocUserResolvers<ContextType>;
	    AuthUser?: AuthUserResolvers<ContextType>;
	    Query?: QueryResolvers<ContextType>;
	    Mutation?: MutationResolvers<ContextType>;
	    AnnotationSubscriptionEvent?: AnnotationSubscriptionEventResolvers<ContextType>;
	    DocumentSubscriptionEvent?: DocumentSubscriptionEventResolvers<ContextType>;
	    MentionSubscriptionEvent?: MentionSubscriptionEventResolvers<ContextType>;
	    ScrollPositionSubscriptionEvent?: ScrollPositionSubscriptionEventResolvers<ContextType>;
	    ConnectedDocUsersSubscriptionEvent?: ConnectedDocUsersSubscriptionEventResolvers<ContextType>;
	    Subscription?: SubscriptionResolvers<ContextType>;
	    AuthPayload?: AuthPayloadResolvers<ContextType>;
	    IgnoreMembership?: IgnoreMembershipResolvers<ContextType>;
	    AnnotationNotFound?: AnnotationNotFoundResolvers<ContextType>;
	    UpdateAnnotationMemberLastReadPayload?: UpdateAnnotationMemberLastReadPayloadResolvers<ContextType>;
	}>;
	/**
	 * @deprecated
	 * Use "Resolvers" root object instead. If you wish to get "IResolvers", add "typesPrefix: I" to your config.
	 */
	export type IResolvers<ContextType = any> = Resolvers<ContextType>;

	import { Context } from '../resolvers';
	import { DeleteResult } from '../../../../types/resolvers-types';
	import { Actions } from '../util/permission';
	type BaseEntity = {
	    createdAt: number | string;
	    updatedAt: number | string;
	    id: string;
	};
	type AuthFunction = (action: Actions, context: Context) => Promise<void>;
	type BaseConstructor<DatabaseType, FetchTypes extends Record<string, any>> = {
	    entity: DatabaseType & {
	        id: string;
	    };
	    context?: Context;
	    getters: Getters<FetchTypes>;
	    update?: (updatedEntity: DatabaseType) => Promise<DatabaseType>;
	    remove?: (id: string) => Promise<DeleteResult>;
	    authorize?: AuthFunction;
	    name: string;
	    from: string;
	};
	type Getters<FetchTypes extends Record<string, any>> = Record<keyof FetchTypes, () => Promise<FetchTypes[keyof FetchTypes]>>;
	export class Base<DatabaseType extends BaseEntity, GraphQLType extends BaseEntity, FetchTypes extends Record<string, any> = Record<string, unknown>> {
	    private data;
	    private getters;
	    private cache;
	    private setMap;
	    private updateFunc?;
	    private deleteFunc?;
	    private resolved;
	    authFunc: AuthFunction | (() => void);
	    from: string;
	    context: Context;
	    id: string;
	    name: string;
	    constructor({ entity, context, getters, update, remove, name, from, authorize }: BaseConstructor<DatabaseType, FetchTypes>);
	    getFromCache<T extends keyof FetchTypes>(key: T): FetchTypes[T] | null;
	    getEntity(): DatabaseType;
	    getAuthFunction(): AuthFunction | (() => void);
	    get<T extends keyof DatabaseType>(key: T): Promise<DatabaseType[T]>;
	    set(key: keyof DatabaseType, value: DatabaseType[keyof DatabaseType]): Promise<void>;
	    delete(useAuth?: boolean): Promise<DeleteResult>;
	    setMultiple(obj: Partial<Record<keyof DatabaseType, DatabaseType[keyof DatabaseType]>>): Promise<void>;
	    setCalculated(key: keyof FetchTypes, value: FetchTypes[keyof FetchTypes]): void;
	    save(useAuth?: boolean): Promise<DatabaseType>;
	    /**
	     * Returns the whole object including all fetched properties
	     */
	    resolve({ asEntity, }?: {
	        asEntity?: boolean;
	    }): Promise<DatabaseType & FetchTypes>;
	    resolveAsEntity(useAuth?: boolean): Promise<GraphQLType>;
	    getCalculated<T extends keyof FetchTypes>(key: T): Promise<FetchTypes[T]>;
	}
	export {};

	type Types = 'string' | 'number' | 'boolean' | 'blob' | 'array' | 'object' | 'function' | 'any';
	type ParamValidationData = {
	    [paramName: string]: [value: any, type?: Types, isRequired?: boolean];
	};
	export const throwError: (functionName: string, msg: string, AuthenticationError?: any) => never;
	/**
	 * Validated that parameters are applied and throws an error if they are empty.
	 * @param {string} functionName The name of the function you are validating for
	 * @param {Object} options Validation options. The key is the name of the parameter, and the value is a tuple with the value and type
	 */
	export const validateParams: (functionSigString: string, options: ParamValidationData) => never;
	export {};

	import type { ApolloUser } from './../resolvers';
	export const Entities: {
	    readonly DOCUMENT: "document";
	    readonly ANNOTATION: "annotation";
	};
	export type Entities = typeof Entities[keyof typeof Entities];
	export const Roles: {
	    readonly DOCUMENT_AUTHOR: "document_author";
	    readonly DOCUMENT_MEMBER: "document_member";
	    readonly ANNOTATION_AUTHOR: "annotation_author";
	    readonly ANY: "any";
	};
	export const Actions: {
	    readonly READ: "read";
	    readonly ADD: "add";
	    readonly EDIT: "edit";
	    readonly DELETE: "delete";
	    readonly INVITE: "invite";
	};
	export type Roles = typeof Roles[keyof typeof Roles];
	export type Actions = typeof Actions[keyof typeof Actions];
	export type AuthMethod = Roles | AuthorizeFunction;
	export type UserPermissionSetting = {
	    document?: Roles | EntityPermissions;
	    annotation?: Roles | EntityPermissions;
	};
	export type PermissionSetting = {
	    document: EntityPermissions;
	    annotation: Omit<EntityPermissions, 'invite'>;
	};
	export type EntityPermissions = {
	    read?: AuthMethod | Array<AuthMethod>;
	    invite?: AuthMethod | Array<AuthMethod>;
	    edit?: AuthMethod | Array<AuthMethod>;
	    delete?: AuthMethod | Array<AuthMethod>;
	    add?: AuthMethod | Array<AuthMethod>;
	};
	export type AuthorizeFunction = (entity: any, user: Pick<ApolloUser, "id" | "createdAt" | "email" | "type">) => Promise<boolean>;
	export const setPermissions: (setting?: UserPermissionSetting) => PermissionSetting;
	const permissionConstants: {
	    Roles: {
	        readonly DOCUMENT_AUTHOR: "document_author";
	        readonly DOCUMENT_MEMBER: "document_member";
	        readonly ANNOTATION_AUTHOR: "annotation_author";
	        readonly ANY: "any";
	    };
	    Actions: {
	        readonly READ: "read";
	        readonly ADD: "add";
	        readonly EDIT: "edit";
	        readonly DELETE: "delete";
	        readonly INVITE: "invite";
	    };
	    Entities: {
	        readonly DOCUMENT: "document";
	        readonly ANNOTATION: "annotation";
	    };
	};
	export default permissionConstants;

	import { PubSub } from 'apollo-server';
	import { ApolloDatabaseAnnotation } from './../resolvers';
	import { User } from './User';
	import { Mention } from './Mention';
	import { NewAnnotationInput, Annotation as ApolloAnnotation } from './../../../../types/resolvers-types';
	import { Base } from './Base';
	import { AnnotationMember } from './AnnotationMember';
	import { Context } from '../resolvers';
	import { AuthMethod } from '../util/permission';
	import { RequestedFields } from '../util/getRequestedFields';
	export type AnnotationPublishEventOptions = {
	    onlyFireForUserId?: string;
	};
	export type MarkAsReadReturnResult = {
	    updatedMember: AnnotationMember;
	};
	export class Annotation extends Base<ApolloDatabaseAnnotation, ApolloAnnotation, {
	    membership: AnnotationMember;
	    author: User | null;
	    mentions: Mention[];
	}> {
	    constructor(annotation: ApolloDatabaseAnnotation, userId: string, from: string, context: Context, skipMembership?: boolean);
	    getAnnotationForUser(userId: string, requestedFields: RequestedFields, skipMembership?: boolean): Annotation;
	    publishEvent(pubsub: PubSub, action: 'INVITE' | 'EDIT' | 'ADD' | 'DELETE', options?: AnnotationPublishEventOptions): Promise<void>;
	    checkPermission(authMethods: Array<AuthMethod> | AuthMethod, context: Context): Promise<boolean>;
	    addMember(user: {
	        id: string;
	    }): Promise<AnnotationMember>;
	    addMention(userId: string): Promise<Mention>;
	    markAsRead(userId: any): Promise<MarkAsReadReturnResult>;
	    static buildFromId(id: string, userId: string, from: string, context: Context): Promise<Annotation>;
	    /**
	     * Creates a new annotation and saves it in the database
	     */
	    static create(input: NewAnnotationInput, from: string, context: Context): Promise<Annotation>;
	}

	import { ApolloDatabaseMention } from './../resolvers';
	import { User } from './User';
	import { Context } from '../resolvers';
	import { Mention as ApolloMention, NewMentionInput } from './../../../../types/resolvers-types';
	import { Base } from './Base';
	import { PubSub } from 'apollo-server';
	export class Mention extends Base<ApolloDatabaseMention, ApolloMention, {
	    mentionedUser: User;
	}> {
	    constructor(mention: ApolloDatabaseMention, from: string, context: Context);
	    publishEvent(pubsub: PubSub, action: 'ADD' | 'DELETE'): Promise<void>;
	    static buildFromId(annotationId: string, userId: string, from: string, context: Context): Promise<Mention>;
	    /**
	     * Creates a new mention and saves it in the database
	     */
	    static create(input: NewMentionInput, from: string, context: Context): Promise<Mention>;
	}

	import { NewAnnotationMemberInput, NewDocumentMemberInput } from '../../../types/resolvers-types';
	type PartialEntity<T1, T2 extends keyof T1> = Partial<{
	    [P in Exclude<keyof T1, T2>]: T1[P];
	} & {
	    [S in T2]?: T1[S];
	} & {
	    id: string;
	    createdAt: string;
	    __typeName: string;
	    lastRead: string;
	}> & Pick<T1, Exclude<keyof T1, T2 | 'id' | 'createdAt' | 'updatedAt' | '__typename' | 'lastRead'>>;
	type FullEntity<T> = T & {
	    createdAt: number;
	    id: string;
	    updatedAt: number;
	};
	export function createEntity<Entity, Ignore extends keyof Entity = never>(data: PartialEntity<Entity, Ignore>): Promise<FullEntity<Entity>>;
	type CreateMemberInput = (NewAnnotationMemberInput | NewDocumentMemberInput) & {
	    lastRead: number | string;
	    annotationCreatedAt?: number;
	};
	export const createMember: <T extends CreateMemberInput>(data: PartialEntity<T, never>) => Promise<T>;
	export {};

	export const setGenerator: (gen: any) => void;
	export const generateId: () => Promise<any>;

	import { ApolloDatabaseAnnotationMember, Context } from '../resolvers';
	import { AnnotationMember as ApolloAnnotationMember } from './../../../../types/resolvers-types';
	import { Base } from './Base';
	type AnnotationMemberRelatedIds = {
	    userId?: string;
	    annotationId?: string;
	    memberId?: string;
	};
	export class AnnotationMember extends Base<ApolloDatabaseAnnotationMember, ApolloAnnotationMember, unknown> {
	    constructor(annotMember: ApolloDatabaseAnnotationMember, from: string, context: Context);
	    static create(userId: string, documentId: string, annotationId: string, lastRead: number | string, annotationCreatedAt: number, from: string, context: Context): Promise<AnnotationMember>;
	    static buildFromId(ids: AnnotationMemberRelatedIds, from: string, context: Context): Promise<AnnotationMember>;
	}
	export {};

	import { FragmentDefinitionNode, SelectionNode } from 'graphql';
	export type DefinitionNodes = {
	    fieldNodes: readonly SelectionNode[];
	    fragments: FragmentDefinitionNode[];
	};
	export type RequestedFields = Record<string, boolean>;
	/**
	 *
	 * @param queryString The original query string from context.req
	 * @returns A flattened tree of all queried fields as key and true as value.
	 * Example -
	 * queryString is
	 *  `query user($id: ID!) {
	        user(id: $id) {
	          id
	          email
	          documents {
	            annotations {
	              membership {
	                lastRead
	              }
	            }
	          }
	        }
	    }`
	 * The returned tree of fields will look like
	    {
	      id: true,
	      email: true,
	      documents: true,
	      annotations: true,
	      membership: true,
	      lastRead: true
	    }
	 */
	export const getRequestedFields: (queryString: string) => RequestedFields;

	import { ApolloDatabaseDocumentMember } from './../resolvers';
	import { User } from './User';
	import { Context } from '../resolvers';
	import { DocumentMember as ApolloDocumentMember } from './../../../../types/resolvers-types';
	import { Base } from './Base';
	export class DocumentMember extends Base<ApolloDatabaseDocumentMember, ApolloDocumentMember, {
	    user: User;
	}> {
	    constructor(docMember: ApolloDatabaseDocumentMember, from: string, context: Context);
	    static create(userId: string, documentId: string, lastRead: number | string, from: string, context: Context): Promise<DocumentMember>;
	    static buildFromId(ids: {
	        documentId?: string;
	        userId?: string;
	        memberId?: string;
	    }, from: string, context: Context): Promise<DocumentMember>;
	}

	import { User } from './../entities/User';
	import { InvitedUserInput } from './../../../../types/resolvers-types';
	import { Context } from '../resolvers';
	const _default: (usersInvited: InvitedUserInput[], from: string, context: Context) => Promise<User[]>;
	/**
	 * Gets a list of users from an array of emails
	 * Creates anonymous accounts if they do not exist
	 */
	export default _default;

	import { EditDocumentInput } from "./../../../../../../types/global-graphql-types";
	export interface EditDocument_editDocument {
	    __typename: "Document";
	    id: string;
	    name: string | null;
	    isPublic: boolean | null;
	}
	export interface EditDocument {
	    editDocument: EditDocument_editDocument;
	}
	export interface EditDocumentVariables {
	    id: string;
	    input: EditDocumentInput;
	}

	import { GraphQLScalarType } from 'graphql';
	const _default: GraphQLScalarType;
	export default _default;

	import { Context } from './../../index';
	const _default: {
	    addUser: (p: any, args: any, context: any) => Promise<import("./../../index").ApolloUser>;
	    loginAnonymous: (p: any, args: any, context: Context) => Promise<{
	        user: import("./../../index").ApolloUser;
	    }>;
	    login: (p: any, args: any, context: Context) => Promise<{
	        user: import("../../resolvers").ApolloDatabaseUser;
	    }>;
	    endSession: (p: any, args: any, context: Context) => Promise<boolean>;
	};
	export default _default;

	import { Context } from './../../index';
	const _default: {
	    addAnnotation: (p: any, args: any, context: Context) => Promise<import("./../../index").ApolloAnnotation>;
	    editAnnotation: (p: any, args: any, context: Context) => Promise<import("./../../index").ApolloAnnotation>;
	    deleteAnnotation: (p: any, args: any, context: Context) => Promise<import("./../../index").DeleteResult | {
	        id: any;
	        successful: boolean;
	        message: string;
	    }>;
	};
	export default _default;

	const _default: {
	    addAnnotationMember: (p: any, args: any, context: any) => Promise<import("../..").ApolloAnnotationMember>;
	    editAnnotationMember: (p: any, args: any, context: any) => Promise<import("../..").ApolloAnnotationMember>;
	    updateAnnotationMemberLastRead: (p: any, args: any, context: any) => Promise<import("../..").ApolloAnnotationMember | {
	        __typename: string;
	        message: string;
	        annotationId: any;
	    }>;
	    deleteAnnotationMember: (p: any, args: any, context: any) => Promise<import("../..").DeleteResult>;
	};
	export default _default;

	import { Context } from './../../index';
	const _default: {
	    inviteUsersToDocument: (_: any, args: any, context: Context) => Promise<import("./../../index").ApolloDocument>;
	    addDocument: (p: any, args: any, context: any) => Promise<import("./../../index").ApolloDocument>;
	    editDocument: (p: any, args: any, context: any) => Promise<import("./../../index").ApolloDocument>;
	    deleteDocument: (p: any, args: any, context: any) => Promise<import("./../../index").DeleteResult>;
	    markAllAsRead: (p: any, args: any, context: any) => Promise<import("./../../index").ApolloDocument>;
	};
	export default _default;

	const _default: {
	    addDocumentMember: (p: any, args: any, context: any) => Promise<import("../..").ApolloDocumentMember>;
	    editDocumentMember: (p: any, args: any, context: any) => Promise<import("../..").ApolloDocumentMember | {
	        __typename: string;
	        message: string;
	    }>;
	    deleteDocumentMember: (p: any, args: any, context: any) => Promise<import("../..").DeleteResult>;
	};
	export default _default;

	const _default: {
	    addMention: (p: any, args: any, context: any) => Promise<import("../../../../../types/resolvers-types").Mention>;
	    editMention: (p: any, args: any, context: any) => Promise<import("../../../../../types/resolvers-types").Mention>;
	    deleteMention: (p: any, args: any, context: any) => Promise<import("../..").DeleteResult>;
	};
	export default _default;

	import { Context } from '../../index';
	const _default: {
	    editScrollSync: (p: any, args: any, context: Context) => {
	        position: any;
	    };
	    deleteScrollSync: (p: any, args: any, context: Context) => {
	        successful: boolean;
	    };
	};
	export default _default;

	const _default: {
	    annotationChanged: {
	        subscribe: import("apollo-server").ResolverFn;
	    };
	    documentChanged: {
	        subscribe: import("apollo-server").ResolverFn;
	    };
	    scrollPositionChanged: {
	        subscribe: import("apollo-server").ResolverFn;
	    };
	    connectedDocUsersChanged: {
	        subscribe: import("apollo-server").ResolverFn;
	    };
	    mentionChanged: {
	        subscribe: import("apollo-server").ResolverFn;
	    };
	};
	export default _default;

	import { UserAuth } from '../index';
	export const getUser: (token: string) => Promise<UserAuth>;

	export const retrieveToken: (cookieStr: string, jwtCookieName: string) => string;

	import { Email, InviteEmailData, MessageEmailData, EmailFunction } from '..';
	import type sgMail from '@sendgrid/mail';
	type AsyncOrSync<T> = Promise<T> | T;
	type TemplateData = {
	    subject?: string;
	} & Record<any, any>;
	export type EmailServiceOptions = {
	    /**
	     * A reference to '@sendgrid/mail'
	     */
	    sendGrid: typeof sgMail;
	    /**
	     * Your sendgrid API key
	     */
	    emailServiceApiKey: string;
	    /**
	     * The email address or domain you verified from your email service
	     */
	    emailSender: string;
	    /**
	     * The name of the sender
	     */
	    senderName?: string;
	    /**
	     * Sendgrid template Ids for each email type
	     */
	    templateId?: {
	        message: string;
	        invite: string;
	    };
	    getTemplateData?: (type: Email, data: InviteEmailData | MessageEmailData) => AsyncOrSync<TemplateData>;
	};
	const sendGridEmailHandler: (emailServiceOptions: EmailServiceOptions) => EmailFunction;
	export default sendGridEmailHandler;

	/// <reference types="node" />
	import { MessageData, InviteEmailData, CollabServerEmailOptions, EmailFunction } from '..';
	export class EmailManager {
	    disabled: boolean;
	    emailHandler: EmailFunction;
	    messageEmailQueue: Array<MessageData>;
	    EMAIL_QUEUE_TIMER: number;
	    timer: NodeJS.Timeout;
	    constructor(emailOptions: CollabServerEmailOptions);
	    addToMessageEmailQueue(data: MessageData): void;
	    deleteFromMessageEmailQueue(annotationId: string): void;
	    updateMessageTextInEmailQueue(annotationId: string, messageText: string): void;
	    resetMessageEmailQueue(): void;
	    triggerMessageEmail(data: Array<MessageData>): Promise<void>;
	    triggerInviteEmail(data: InviteEmailData): void;
	    uniqueArray<T>(arrayOfObjects: Array<T>): Array<T>;
	}

	import { AnnotationMember } from './../entities/AnnotationMember';
	import { DocumentMember } from './../entities/DocumentMember';
	import { Document } from './../entities/Document';
	import { User } from './../entities/User';
	import { Annotation } from './../entities/Annotation';
	type AllowedCacheTypes = User | User[] | Document | Document[] | DocumentMember | DocumentMember[] | AnnotationMember | AnnotationMember[] | Annotation | Annotation[];
	/**
	 * @ignore
	 * Caches anything fetched in the current request
	 */
	export default class ContextCache {
	    private cache;
	    id: string;
	    constructor();
	    set(item: AllowedCacheTypes, as?: string): void;
	    get(...ids: string[]): AllowedCacheTypes;
	    remove(id: any): void;
	}
	export {};

	export default class RequestStats {
	    query: string;
	    id: string;
	    totalQueryCount: number;
	    cachedResponseCount: number;
	    databaseResponseCount: number;
	    startTime: number;
	    requests: Array<any>;
	    totalMutationCount: number;
	    constructor(query: string);
	    end(): string;
	    pushRequest(request: any): void;
	}

	export default function getCacheKey(...params: any[]): any;

	import ConnectedUserMap from '../util/ConnectedUserMap';
	import type { PubSub } from 'apollo-server';
	export const leaveScrollSyncEvent: (disconnectedUserId: string, pubsub: PubSub, connectedUsers: ConnectedUserMap) => void;
	export const leaveConnectedDocUsersMap: (disconnectedUserId: string, pubsub: PubSub, connectedUsers: ConnectedUserMap) => void;

}